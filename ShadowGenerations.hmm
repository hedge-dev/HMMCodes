Patch "Show Frame Rate on Title Bar" in "System" by "Hyper & Sajid" 
//
    #lib "DeltaTime"
    #lib "Win32"

    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Threading;

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern int GetWindowTextLength(IntPtr hWnd);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern bool SetWindowText(IntPtr hWnd, String lpString);

    static bool _isOriginalTitleCaptured = false;

    static string _originalTitle;
//
{
    new Thread
    (
        delegate()
        {
            while (true)
            {
                var windowHandle = Win32.GetGameWindowHandle();

                if (windowHandle == IntPtr.Zero)
                    continue;
                    
                if (!_isOriginalTitleCaptured)
                {
                    if (string.IsNullOrEmpty(_originalTitle))
                    {
                        var title = new StringBuilder(GetWindowTextLength(windowHandle) + 1);

                        GetWindowText(windowHandle, title, title.Capacity);

                        _originalTitle = title.ToString();
                    }
                    else
                    {
                        _isOriginalTitleCaptured = true;
                    }
                }
                else
                {
                    SetWindowText(windowHandle, $"{_originalTitle} - {DeltaTime.GetFrameRateAverage()} FPS ({DeltaTime.GetDeltaTimeAverage()} ms)");
                }

                Thread.Sleep((int)DeltaTime.GetDeltaTimeMilliseconds());
            }
        }
    )
    .Start();
}
Code "Always Hide Mouse Cursor" in "System" by "Hyper" does
/*
Keeps the mouse cursor hidden at all times when the game window is focused.

This prevents the mouse cursor appearing under certain conditions, even if the primary input method is a controller.
*/
//
    #lib "Win32"
    
    [System.Runtime.InteropServices.DllImport("user32.dll")]
    static extern nint SetCursor(nint hCursor);
//
{
    if (!Win32.IsGameForegroundWindow())
        return;
    
    SetCursor(0);
}
Library "XInput" by "Hyper" 
{
    #lib "MathHelpers"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [DllImport("xinput1_4.dll", EntryPoint = "XInputGetState")]
    public extern int XInputGetState(int in_dwUserIndex, ref State in_pState);
    
    [DllImport("xinput1_4.dll", EntryPoint = "XInputSetState")]
    public extern int XInputSetState(int in_dwUserIndex, ref Vibration in_pVibration);

    public const short XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE = 7849;
    public const short XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE = 8689;

    private static float _leftMotorSpeed = 0.0f;
    private static float _rightMotorSpeed = 0.0f;

    [Flags]
    public enum Buttons : ushort
    {
        DPAD_UP        = 0x0001,
        DPAD_DOWN      = 0x0002,
        DPAD_LEFT      = 0x0004,
        DPAD_RIGHT     = 0x0008,
        START          = 0x0010,
        BACK           = 0x0020,
        LEFT_THUMB     = 0x0040,
        RIGHT_THUMB    = 0x0080,
        LEFT_SHOULDER  = 0x0100,
        RIGHT_SHOULDER = 0x0200,
        A              = 0x1000,
        B              = 0x2000,
        X              = 0x4000,
        Y              = 0x8000
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct State
    {
        public int dwPacketNumber;
        public Gamepad Gamepad;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Gamepad
    {
        public Buttons wButtons;
        public byte bLeftTrigger;
        public byte bRightTrigger;
        public short sThumbLX;
        public short sThumbLY;
        public short sThumbRX;
        public short sThumbRY;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Vibration
    {
        public ushort wLeftMotorSpeed;
        public ushort wRightMotorSpeed;

        public Vibration(ushort in_leftMotorSpeed, ushort in_rightMotorSpeed)
        {
            wLeftMotorSpeed = in_leftMotorSpeed;
            wRightMotorSpeed = in_rightMotorSpeed;

            _leftMotorSpeed = in_leftMotorSpeed / 65535.0f;
            _rightMotorSpeed = in_rightMotorSpeed / 65535.0f;
        }

        public Vibration(float in_leftMotorSpeed, float in_rightMotorSpeed)
        {
            wLeftMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_leftMotorSpeed);
            wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_rightMotorSpeed);

            _leftMotorSpeed = in_leftMotorSpeed;
            _rightMotorSpeed = in_rightMotorSpeed;
        }

        public Vibration(ushort in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = in_motorSpeed;
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed / 65535.0f;
        }

        public Vibration(float in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_motorSpeed);
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed;
        }
    }

    public State? GetState()
    {
        var pState = new State();

        if (XInputGetState(0, ref pState) != 0)
            return null;

        return pState;
    }

    public void SetState(Vibration in_vibration)
    {
        XInputSetState(0, ref in_vibration);
    }

    public Vector2 GetAnalog(int in_analogIndex, bool in_isTestDeadzone = true)
    {
        var pState = GetState();

        if (pState == null)
            return Vector2.Zero;

        Vector2 v = Vector2.Zero;

        switch (in_analogIndex)
        {
            case 0:
                v = new Vector2(pState.Value.Gamepad.sThumbLX / 32767.0f, pState.Value.Gamepad.sThumbLY / 32767.0f);
                break;

            case 1:
                v = new Vector2(pState.Value.Gamepad.sThumbRX / 32767.0f, pState.Value.Gamepad.sThumbRY / 32767.0f);
                break;
        }

        if (in_isTestDeadzone)
        {
            v = IsAnalogNeutral(in_analogIndex)
                ? Vector2.Zero
                : v;
        }

        return v;
    }

    // Use Player.Input for keyboard parity!
    public bool IsButtonDown(Buttons in_buttons)
    {
        var pState = GetState();

        if (pState == null)
            return false;

        return (pState.Value.Gamepad.wButtons & in_buttons) != 0;
    }

    public float GetTrigger(int in_triggerIndex)
    {
        var pState = GetState();

        if (pState == null)
            return 0;

        switch (in_triggerIndex)
        {
            case 0:
                return pState.Value.Gamepad.bLeftTrigger / 255.0f;

            case 1:
                return pState.Value.Gamepad.bRightTrigger / 255.0f;
        }

        return 0;
    }

    public bool IsAnalogNeutral(int in_analogIndex)
    {
        var pState = GetState();

        if (pState == null)
            return true;

        switch (in_analogIndex)
        {
            case 0:
            {
                short x = pState.Value.Gamepad.sThumbLX;
                short y = pState.Value.Gamepad.sThumbLY;

                return x < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;
            }

            case 1:
            {
                short x = pState.Value.Gamepad.sThumbRX;
                short y = pState.Value.Gamepad.sThumbRY;

                return x < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE;
            }
        }

        return true;
    }

    public Vibration GetVibration()
    {
        return new Vibration(_leftMotorSpeed, _rightMotorSpeed);
    }

    public void SetVibration(float in_value)
    {
        SetState(new Vibration(in_value));
    }

    public void SetVibration(int in_motorIndex, float in_value)
    {
        switch (in_motorIndex)
        {
            case 0:
            {
                SetState(new Vibration(in_value, _rightMotorSpeed));
                break;
            }

            case 1:
            {
                SetState(new Vibration(_leftMotorSpeed, in_value));
                break;
            }
        }
    }
}



Library "HMM" by "Hyper"
{
    #lib "INI"

    using Microsoft.Win32;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Threading;

    public string GetGameDirectory()
    {
        return Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName);
    }

    public Dictionary<string, Dictionary<string, string>> GetModsDatabase()
    {
        string cpkredirCfgPath = Path.Combine(GetGameDirectory(), "cpkredir.ini");
        
        if (!File.Exists(cpkredirCfgPath))
            return new();

        var cpkredirCfg = INI.Read(cpkredirCfgPath);
        string modsDbPath = cpkredirCfg["CPKREDIR"]["ModsDbIni"];

        if (!File.Exists(modsDbPath))
            return new();

        return INI.Read(modsDbPath);
    }

    public List<Mod> GetMods()
    {
        List<Mod> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb.Count <= 0)
            return result;
        
        int activeModCount = INI.Parse<int>(modsDb["Main"]["ActiveModCount"], 0);

        foreach (var entry in modsDb["Mods"].Keys)
        {
            for (int i = 0; i < activeModCount; i++)
            {
                if (modsDb["Main"][$"ActiveMod{i}"].Contains(entry))
                {
                    result.Add(new Mod(modsDb["Mods"][entry]));
                }
            }
        }

        return result;
    }

    public Mod GetModByID(string in_id)
    {
        foreach (var mod in GetMods())
        {
            if (mod.ID == in_id)
                return mod;
        }

        return null;
    }

    public List<Mod> FindModsByName(string name)
    {
        List<Mod> result = new();

        foreach (var mod in GetMods())
        {
            if (mod.Name.Contains(name))
            {
                result.Add(mod);
            }
        }

        return result;
    }

    public List<string> GetCodes()
    {
        List<string> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        foreach (var value in modsDb["Codes"].Values)
            result.Add(value);

        return result;
    }

    public class Mod
    {
        public string Name { get; set; }
        public string Version { get; set; }
        public string Author { get; set; }
        public string Description { get; set; }
        public string Date { get; set; }
        public string AuthorURL { get; set; }
        public string UpdateServer { get; set; }
        public string SaveFile { get; set; }
        public string ID { get; set; }
        public List<string> IncludeDirs { get; set; } = new();
        public List<ModDependency> Dependencies { get; set; } = new();
        public string DLLFile { get; set; }
        public string CodeFile { get; set; }
        public string ConfigSchemaFile { get; set; }

        public string Path { get; set; }
        public Dictionary<string, Dictionary<string, string>> Ini { get; set; } = new();

        public Mod(string modIniPath)
        {
            var ini = INI.Read(modIniPath);

            if (ini == null)
                return;

            Name             = INI.GetField<string>(ini, "Desc", "Title", Name);
            Version          = INI.GetField<string>(ini, "Desc", "Version", Version);
            Author           = INI.GetField<string>(ini, "Desc", "Author", Author);
            Description      = INI.GetField<string>(ini, "Desc", "Description", Description);
            Date             = INI.GetField<string>(ini, "Desc", "Date", Date);
            AuthorURL        = INI.GetField<string>(ini, "Desc", "AuthorURL", AuthorURL);
            UpdateServer     = INI.GetField<string>(ini, "Main", "UpdateServer", UpdateServer);
            SaveFile         = INI.GetField<string>(ini, "Main", "SaveFile", SaveFile);
            ID               = INI.GetField<string>(ini, "Main", "ID", ID);
            DLLFile          = INI.GetField<string>(ini, "Main", "DLLFile", DLLFile);
            CodeFile         = INI.GetField<string>(ini, "Main", "CodeFile", CodeFile);
            ConfigSchemaFile = INI.GetField<string>(ini, "Main", "ConfigSchemaFile", ConfigSchemaFile);

            Path             = System.IO.Path.GetDirectoryName(modIniPath);
            Ini              = ini;

            int includeDirCount = INI.GetField<int>(ini, "Main", "IncludeDirCount", 1);

            for (int i = 0; i < includeDirCount; i++)
                IncludeDirs.Add(INI.GetField<string>(ini, "Main", $"IncludeDir{i}", "."));

            int dependencyCount = INI.GetField<int>(ini, "Main", "DependsCount", 0);

            for (int i = 0; i < dependencyCount; i++)
                Dependencies.Add(new ModDependency(INI.GetField<string>(ini, "Main", $"Depends{i}", "")));
        }
    }

    public class ModDependency
    {
        public string ID { get; set; }

        public string Name { get; set; }
        
        public string Link { get; set; }

        public string Version { get; set; }

        public ModDependency(string in_id, string in_name, string in_link, string in_version)
        {
            ID = in_id;
            Name = in_name;
            Link = in_link;
            Version = in_version;
        }

        public ModDependency(string in_csv)
        {
            var fields = in_csv.Split('|');

            for (int i = 0; i < fields.Length; i++)
            {
                switch (i)
                {
                    case 0:
                        ID = fields[i];
                        break;

                    case 1:
                        Name = fields[i];
                        break;

                    case 2:
                    {
                        if (fields.Length > 2)
                        {
                            Link = fields[i];
                        }
                        else
                        {
                            Version = fields[i];
                        }

                        break;
                    }

                    case 3:
                        Version = fields[i];
                        break;
                }
            }
        }
    }

    public static class RegistryConfig
    {
        public static string ConfigPath { get; } = @"SOFTWARE\HEDGEMM";

        public static bool CheckLoaderUpdates { get; set; } = true;
        public static bool CheckManagerUpdates { get; set; } = true;
        public static bool CheckModUpdates { get; set; } = true;
        public static int CodesSortingColumnIndex { get; set; } = 1;
        public static bool CodesUseTreeView { get; set; } = true;
        public static string ExecutablePath { get; set; }
        public static string ExtraGameDirectories { get; set; }
        public static bool KeepOpen { get; set; } = true;
        public static string LastGameDirectory { get; set; }
        public static string UILanguage { get; set; }
        public static string UITheme { get; set; }
        public static bool UpdateCodesOnLaunch { get; set; } = true;

        static RegistryConfig()
        {
            Load();
        }

        public static void Load()
        {
            var personalizeKey = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize");

            bool isLightTheme = false;
            if (personalizeKey != null)
            {
                var useLightThemeStr = personalizeKey.GetValue("AppsUseLightTheme", 0)?.ToString();

                if (int.TryParse(useLightThemeStr, out int out_isLightTheme))
                    isLightTheme = out_isLightTheme != 0;

                personalizeKey.Close();
            }

            var key = Registry.CurrentUser.CreateSubKey(ConfigPath);

            LastGameDirectory       = (string)key.GetValue("LastGame", string.Empty);
            ExtraGameDirectories    = (string)key.GetValue(nameof(ExtraGameDirectories), string.Empty);
            UILanguage              = (string)key.GetValue(nameof(UILanguage), Thread.CurrentThread.CurrentCulture.Name);
            UITheme                 = (string)key.GetValue(nameof(UITheme), isLightTheme ? "LightTheme" : "DarkerTheme");
            CodesSortingColumnIndex = (int)key.GetValue(nameof(CodesSortingColumnIndex), 1);
            CodesUseTreeView        = (int)key.GetValue(nameof(CodesUseTreeView), 1) != 0;
            UpdateCodesOnLaunch     = (int)key.GetValue(nameof(UpdateCodesOnLaunch), 1) != 0;
            CheckManagerUpdates     = (int)key.GetValue(nameof(CheckManagerUpdates), 1) != 0;
            CheckLoaderUpdates      = (int)key.GetValue(nameof(CheckLoaderUpdates), 1) != 0;
            CheckModUpdates         = (int)key.GetValue(nameof(CheckModUpdates), 1) != 0;
            KeepOpen                = (int)key.GetValue(nameof(KeepOpen), 1) != 0;

            key.Close();
        }

        public static void Save()
        {
            var key = Registry.CurrentUser.CreateSubKey(ConfigPath);

            key.SetValue("ExecutablePath", Assembly.GetExecutingAssembly().Location);
            key.SetValue("LastGame", LastGameDirectory);
            key.SetValue(nameof(ExtraGameDirectories), ExtraGameDirectories);
            key.SetValue(nameof(UILanguage), UILanguage);
            key.SetValue(nameof(UITheme), UITheme);
            key.SetValue(nameof(CodesSortingColumnIndex), CodesSortingColumnIndex);
            key.SetValue(nameof(CodesUseTreeView), CodesUseTreeView ? 1 : 0);
            key.SetValue(nameof(UpdateCodesOnLaunch), UpdateCodesOnLaunch ? 1 : 0);
            key.SetValue(nameof(CheckManagerUpdates), CheckManagerUpdates ? 1 : 0);
            key.SetValue(nameof(CheckLoaderUpdates), CheckLoaderUpdates ? 1 : 0);
            key.SetValue(nameof(CheckModUpdates), CheckModUpdates ? 1 : 0);
            key.SetValue(nameof(KeepOpen), KeepOpen ? 1 : 0);

            key.Close();
        }
    }
}
Library "Win32" by "Hyper"
{
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    private static IntPtr _windowHandle = IntPtr.Zero;

    [DllImport("kernel32.dll")]
    private static extern IntPtr GetConsoleWindow();

    [DllImport("user32.dll")]
    static extern IntPtr GetForegroundWindow();

    [LibraryUpdate]
    public void Update()
    {
        if (_windowHandle == IntPtr.Zero)
        {
            var hwnd = Process.GetCurrentProcess().MainWindowHandle;

            if (hwnd == GetConsoleWindow())
                return;

            _windowHandle = hwnd;
        }
    }

    public static IntPtr GetGameWindowHandle()
    {
        return _windowHandle;
    }

    public static bool IsGameForegroundWindow()
    {
        return GetForegroundWindow() == _windowHandle;
    }
}
Library "Globals" by "Hyper"
{
    using System.Collections.Generic;

    private Dictionary<string, object> _globals = new();

    public void Add(string in_name, object in_obj)
    {
        if (_globals.ContainsKey(in_name))
            return;

        _globals.Add(in_name, in_obj);
    }

    public void Remove(string in_name)
    {
        _globals.Remove(in_name);
    }
    
    public object Get(string in_name)
    {
        if (!_globals.ContainsKey(in_name))
            return null;

        return _globals[in_name];
    }

    public T Get<T>(string in_name, T in_defaultValue = default)
    {
        var result = Get(in_name);

        if (result == null)
            return in_defaultValue;

        return (T)result;
    }

    public bool GetFlag(string in_name)
    {
        return Get<bool>(in_name);
    }

    public void Set(string in_name, object in_obj)
    {
        if (!_globals.ContainsKey(in_name))
            return;

        _globals[in_name] = in_obj;
    }
}
Library "Logger" by "Hyper"
{
    #define PRINT_OBJECT(obj, format, caller) Logger.Utility(#obj + " = " + obj.ToString(format), caller);
    #define PRINT_OBJECT(obj, format) Logger.Utility(#obj + " = " + obj.ToString(format));

    public enum LogLevel
    {
        None,
        Utility,
        Warning,
        Error
    }

    public void Log(object message, LogLevel level = LogLevel.None, string caller = "")
    {
        var oldColour = Console.ForegroundColor;

        switch (level)
        {
            case LogLevel.Warning:
                Console.ForegroundColor = ConsoleColor.Yellow;
                break;

            case LogLevel.Error:
                Console.ForegroundColor = ConsoleColor.Red;
                break;

            case LogLevel.Utility:
                Console.ForegroundColor = ConsoleColor.Green;
                break;
        }

        Console.WriteLine(string.IsNullOrEmpty(caller) ? message.ToString() : $"[{caller}] {message}");

        Console.ForegroundColor = oldColour;
    }

    public void Utility(object message, string caller = "")
    {
        Log(message, LogLevel.Utility, caller);
    }

    public void Warning(object message, string caller = "")
    {
        Log(message, LogLevel.Warning, caller);
    }

    public void Error(object message, string caller = "")
    {
        Log(message, LogLevel.Error, caller);
    }
}
Library "StringMapOperation" by "ĐeäTh" 
{
    /// <summary>
    /// Computes a hash based on the input string.
    /// </summary>
    /// <param name="in_key">The string to hash.</param>
    /// <returns>A string hash.</returns>
    public uint ComputeHash(string in_key)
    {
        uint hash = in_key[0];

        for (int i = 1; i < in_key.Length; i++)
            hash = in_key[i] + 31 * hash;

        return hash & 0x7FFFFFFF;
    }
}
Library "MathHelpers" by "Hyper" 
{
    using System.Collections.Generic;

    public T Clamp<T>(T in_value, T in_minValue, T in_maxValue) where T : IComparable<T>
    {
        if (in_value.CompareTo(in_minValue) < 0)
        {
            return in_minValue;
        }
        else if (in_value.CompareTo(in_maxValue) > 0)
        {
            return in_maxValue;
        }
        else
        {
            return in_value;
        }
    }

    public T Clamp01<T>(T value) where T : IComparable<T>
    {
        if (value.CompareTo(default(T)) < 0)
        {
            return default(T);
        }
        else if (value.CompareTo((T)Convert.ChangeType(1, typeof(T))) > 0)
        {
            return (T)Convert.ChangeType(1, typeof(T));
        }
        else
        {
            return value;
        }
    }

    public T FloatPercentToRange<T>(float in_value)
    {
        if (typeof(T) == typeof(sbyte))
        {
            return (T)(object)(byte)(in_value * (sbyte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(byte))
        {
            return (T)(object)(byte)(in_value * (byte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(short))
        {
            return (T)(object)(short)(in_value * (short.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ushort))
        {
            return (T)(object)(ushort)(in_value * (ushort.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(int))
        {
            return (T)(object)(int)(in_value * (int.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(uint))
        {
            return (T)(object)(uint)(in_value * (uint.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(long))
        {
            return (T)(object)(long)(in_value * (long.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ulong))
        {
            return (T)(object)(ulong)(in_value * (ulong.MaxValue * 1.0f));
        }
        
        return default;
    }
    
    public float Lerp(float in_start, float in_end, float in_time)
    {
        return in_start + (in_end - in_start) * in_time;
    }

    public static float InverseLerp(float a, float b, float value)
    {
        if (a == b)
            return 0.0f;

        return Clamp01<float>((value - a) / (b - a));
    }

    public static float Remap(float in_value, float in_sourceFrom, float in_sourceTo, float in_destinationFrom, float in_destinationTo)
    {
        return (in_value - in_sourceFrom) / (in_sourceTo - in_sourceFrom) * (in_destinationTo - in_destinationFrom) + in_destinationFrom;
    }

    public static float ToDegrees(float in_radians)
    {
        return in_radians * (180.0f / (float)Math.PI);
    }

    public static float ToRadians(float in_degrees)
    {
        return in_degrees * ((float)Math.PI / 180.0f);
    }

    public static float WrapToRadians(float in_value)
    {
        float sign = in_value > 0.0f ? 1.0f : -1.0f;
        float mod = (float)Math.Abs(in_value) % 6.28319f;

        return mod * sign;
    }
}
Library "VectorHelpers" by "Hyper" 
{
    #lib "MathHelpers"

    #load "System.Numerics.dll"

    using System.Numerics;

    public static float Angle(Quaternion in_first, Quaternion in_second)
    {
        var dot = MathHelpers.Clamp(Quaternion.Dot(in_first, in_second), -1.0f, 1.0f);

        return MathHelpers.ToDegrees((float)Math.Acos(2.0f * dot * dot - 1.0f));
    }

    public static float SignedAngle(Vector3 in_first, Vector3 in_second, Vector3 in_axis)
    {
        var angle = (float)Math.Acos(MathHelpers.Clamp(Vector3.Dot(Vector3.Normalize(in_first), Vector3.Normalize(in_second)), -1.0f, 1.0f));
        var cross = Vector3.Cross(in_first, in_second);
        var sign = Vector3.Dot(cross, in_axis) >= 0 ? 1.0f : -1.0f;

        return angle * sign;
    }

    public static Vector3 ClampMagnitude(Vector3 in_vector, float in_maxMagnitude)
    {
        if (in_vector.Length() > in_maxMagnitude * in_maxMagnitude)
            return Vector3.Normalize(in_vector) * in_maxMagnitude;

        return in_vector;
    }

    public static Vector3 GetRight(Quaternion in_rotation)
    {
        return Vector3.Transform(Vector3.UnitX, Quaternion.Normalize(in_rotation));
    }

    public static Vector3 GetUp(Quaternion in_rotation)
    {
        return Vector3.Transform(Vector3.UnitY, Quaternion.Normalize(in_rotation));
    }

    public static Vector3 GetForward(Quaternion in_rotation)
    {
        return Vector3.Transform(Vector3.UnitZ, Quaternion.Normalize(in_rotation));
    }

    public static float GetMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Length();
    }

    public static float GetHorizontalMagnitude(Vector3 in_velocity)
    {
        return (float)Math.Sqrt(in_velocity.X * in_velocity.X + in_velocity.Z * in_velocity.Z);
    }

    public static float GetPitch(Quaternion in_rotation, bool in_isConvertToDegrees = false)
    {
        var result = (float)Math.Atan2(2.0f * (in_rotation.W * in_rotation.Y + in_rotation.Z * in_rotation.X),
            1.0f - 2.0f * (in_rotation.Y * in_rotation.Y + in_rotation.Z * in_rotation.Z));

        return in_isConvertToDegrees
            ? MathHelpers.ToDegrees(result)
            : result;
    }

    public static float GetRoll(Quaternion in_rotation, bool in_isConvertToDegrees = false)
    {
        var result = (float)Math.Asin(2.0f * (in_rotation.W * in_rotation.Z - in_rotation.X * in_rotation.Y));

        return in_isConvertToDegrees
            ? MathHelpers.ToDegrees(result)
            : result;
    }

    public static float GetVerticalMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Y;
    }

    public static float GetYaw(Quaternion in_rotation, bool in_isConvertToDegrees = false)
    {
        var result = (float)Math.Atan2(2.0 * (in_rotation.Y * in_rotation.Z + in_rotation.W * in_rotation.X),
            in_rotation.W * in_rotation.W - in_rotation.X * in_rotation.X - in_rotation.Y * in_rotation.Y + in_rotation.Z * in_rotation.Z);

        return in_isConvertToDegrees
            ? MathHelpers.ToDegrees(result)
            : result;
    }

    public static Vector3 GetYawPitchRoll(Quaternion in_rotation, bool in_isConvertToDegrees = false)
    {
        return new Vector3
        (
            GetYaw(in_rotation, in_isConvertToDegrees),
            GetPitch(in_rotation, in_isConvertToDegrees),
            GetRoll(in_rotation, in_isConvertToDegrees)
        );
    }

    public static Vector3 Lerp(Vector3 in_start, Vector3 in_end, float in_time)
    {
        in_time = MathHelpers.Clamp(in_time, 0.0f, 1.0f);

        return new Vector3
        (
            in_start.X + (in_end.X - in_start.X) * in_time,
            in_start.Y + (in_end.Y - in_start.Y) * in_time,
            in_start.Z + (in_end.Z - in_start.Z) * in_time
        );
    }

    public static Quaternion LookRotation(Vector3 in_forward, Vector3 in_upward)
    {
        in_forward = Vector3.Normalize(in_forward);
        in_upward = Vector3.Normalize(in_upward);

        var right = Vector3.Cross(in_upward, in_forward);
        in_upward = Vector3.Cross(in_forward, right);

        var m = new Matrix4x4
        (
            right.X,      right.Y,      right.Z,      0.0f,
            in_upward.X,  in_upward.Y,  in_upward.Z,  0.0f,
            in_forward.X, in_forward.Y, in_forward.Z, 0.0f,
            0.0f,         0.0f,         0.0f,         1.0f
        );

        return Quaternion.CreateFromRotationMatrix(m);
    }

    public static Quaternion RotateTowards(Quaternion in_from, Quaternion in_to, float in_maxRadiansDelta)
    {
        float angle = Angle(in_from, in_to);

        if (angle <= in_maxRadiansDelta || angle == 0.0f)
            return in_to;

        return Quaternion.Slerp(in_from, in_to, in_maxRadiansDelta / angle);
    }

    public static Quaternion LookRotation(Vector3 in_forward)
    {
        return LookRotation(in_forward, Vector3.UnitY);
    }

    public static Vector3 ProjectOnPlane(Vector3 in_vector, Vector3 in_normal)
    {
        in_normal = Vector3.Normalize(in_normal);
        
        return in_vector - Vector3.Dot(in_vector, in_normal) * in_normal;
    }
}
Library "Helpers" by "Hyper & Sajid"
{
    #lib "StringMapOperation"

    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Text;

    /// <summary>
    /// Creates an `__stdcall` delegate with an unmanaged function pointer based on the provided function signature.
    /// </summary>
    /// <example>
    /// <code><![CDATA[
    /// Library
    /// {
    ///     #include "Helpers" noemit
    ///     
    ///     UNMANAGED_FUNCTION(void, MyUnmanagedFunction, string in_str)
    ///     {
    ///         Console.WriteLine("Hello from native code!");
    ///     }
    ///     
    ///     public void Init()
    ///     {
    ///         // This can be used for mid-asm hooks to call your own functions from the game code.
    ///         var ptrToMyUnmanagedFunction = GET_UNMANAGED_FUNCTION_PTR(MyUnmanagedFunction);
    ///     }
    /// }
    /// ]]></code>
    /// </example>
    /// <param name="in_returnType">The return type of the unmanaged function.</param>
    /// <param name="in_functionName">The name of the unmanaged function.</param>
    /// <param name="...">The arguments of the unmanaged function.</param>
    #define UNMANAGED_FUNCTION(in_returnType, in_functionName, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        public delegate in_returnType T##in_functionName(__VA_ARGS__); \
        public static T##in_functionName _del##in_functionName = new T##in_functionName(in_functionName); \
        public static long _fp##in_functionName = (long)System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(_del##in_functionName); \
        public static in_returnType in_functionName(__VA_ARGS__)

    /// <summary>
    /// Creates an `__stdcall` delegate based on the provided function signature.
    /// </summary>
    /// <example>
    /// <code><![CDATA[
    /// Code
    /// //
    ///     #include "Helpers" noemit
    ///     
    ///     UNMANAGED_FUNCTION_DELEGATE(void, GetNameHash)
    /// //
    /// {
    ///     // Calls the function at 0xDEADBEEF using this function signature.
    ///     CREATE_UNMANAGED_FUNCTION_PTR(GetNameHash, 0xDEADBEEF)();
    /// }
    /// ]]></code>
    /// </example>
    /// <param name="in_returnType">The return type of the unmanaged function.</param>
    /// <param name="in_functionName">The name of the unmanaged function.</param>
    /// <param name="...">The arguments of the unmanaged function.</param>
    #define UNMANAGED_FUNCTION_DELEGATE(in_returnType, in_functionName, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        public delegate in_returnType in_functionName(__VA_ARGS__);

    /// <summary>
    /// Gets a pointer created by `UNMANAGED_FUNCTION` by name.
    /// </summary>
    /// <param name="in_functionName">The name of the unmanaged function.</param>
    /// <returns>A pointer to the unmanaged function.</returns>
    #define GET_UNMANAGED_FUNCTION_PTR(in_functionName) _fp##in_functionName

    /// <summary>
    /// Creates a delegate using the signature created by `UNMANAGED_FUNCTION_DELEGATE`.
    /// </summary>
    /// <param name="in_functionName">The name of the unmanaged function.</param>
    /// <param name="in_location">The location of the function.</param>
    /// <returns>A delegate for the unmanaged function.</returns>
    #define CREATE_UNMANAGED_FUNCTION_PTR(in_functionName, in_location) System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<in_functionName>((IntPtr)(in_location))

    /// <summary>
    /// Creates a function pointer to native code at the specified location.
    /// </summary>
    /// <example>
    /// <code><![CDATA[
    /// Code
    /// //
    ///     #include "Helpers" noemit
    ///     
    ///     FUNCTION_PTR(void, GetNameHash, 0xDEADBEEF)
    /// //
    /// {
    ///     GET_FUNCTION_PTR(GetNameHash)();
    /// }
    /// ]]></code>
    /// </example>
    /// <param name="in_returnType">The return type of the unmanaged function.</param>
    /// <param name="in_functionName">The name of the unmanaged function.</param>
    /// <param name="in_location">The location of the function.</param>
    /// <param name="...">The arguments of the unmanaged function.</param>
    #define FUNCTION_PTR(in_returnType, in_functionName, in_location, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        public delegate in_returnType T##in_functionName(__VA_ARGS__); \
        public static long _addr##in_functionName = in_location;
    
    /// <summary>
    /// Creates a function pointer to a virtual function at an instance of a struct.
    /// </summary>
    /// <example>
    /// <code><![CDATA[
    /// Code
    /// //
    ///     #include "Helpers" noemit
    ///
    ///     public struct MyStruct
    ///     {
    ///         VFUNCTION_PTR(MyStruct, 1, void, GetNameHash)
    ///     }
    /// //
    /// {
    ///     myInstanceOfMyStruct->GetNameHash()();
    /// }
    /// ]]></code>
    /// </example>
    /// <param name="in_thisType">The struct type this is nested inside.</param>
    /// <param name="in_functionIndex">The index of this function in the virtual function table.</param>
    /// <param name="in_returnType">The return type of the unmanaged function.</param>
    /// <param name="in_functionName">The name of the unmanaged function.</param>
    /// <param name="in_location">The location of the function.</param>
    /// <param name="...">The arguments of the unmanaged function.</param>
    #define VFUNCTION_PTR(in_thisType, in_functionIndex, in_returnType, in_functionName, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        public delegate in_returnType T##in_functionName(__VA_ARGS__); \
        public T##in_functionName in_functionName() \
        { \
            fixed (in_thisType* pThis = &this) \
                return System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<T##in_functionName>((IntPtr)(*(long*)((*(long*)pThis) + (1 * sizeof(nint)) * in_functionIndex))); \
        }

    /// <summary>
    /// Gets a pointer created by `FUNCTION_PTR` by name.
    /// </summary>
    /// <param name="in_functionName">The name of the function pointer.</param>
    /// <returns>A delegate to the native function.</returns>
    #define GET_FUNCTION_PTR(in_functionName) System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<T##in_functionName>((IntPtr)_addr##in_functionName)

    /// <summary>
    /// Creates a fixed byte array with a special accessor for the real type.
    /// </summary>
    /// <param name="in_type">The real type of this array.</param>
    /// <param name="in_name">The name of this array.</param>
    /// <param name="in_size">The size of this array.</param>
    #define UNMANAGED_FIXED_ARRAY(in_type, in_name, in_size) \
        public fixed byte _##in_name[in_size]; \
        public in_type* in_name \
        { \
            get \
            { \
                fixed (byte* p_##in_name = _##in_name) \
                    return (in_type*)p_##in_name; \
            } \
        }

    #define MAKE_GENERIC_API(in_functionName) \
        public T* in_functionName<T>() where T : unmanaged \
        { \
            var name = Helpers.GetInternalName(typeof(T)); \
\
            return (T*)in_functionName(string.IsNullOrEmpty(name) ? typeof(T).Name : name); \
        } \

    #define MAKE_STATIC_GENERIC_API(in_functionName) \
        public static T* in_functionName<T>() where T : unmanaged \
        { \
            var name = Helpers.GetInternalName(typeof(T)); \
\
            return (T*)in_functionName(string.IsNullOrEmpty(name) ? typeof(T).Name : name); \
        } \

    /// <summary>
    /// Gets a pointer to an ANSI string.
    /// </summary>
    /// <param name="in_str">The ANSI string to get a pointer to.</param>
    /// <returns>A pointer to the input ANSI string.</returns>
    #define TO_STRING_PTR(in_str) (long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi((##in_str##))

    /// <summary>
    /// Gets a pointer to a Unicode string.
    /// </summary>
    /// <param name="in_str">The Unicode string to get a pointer to.</param>
    /// <returns>A pointer to the input Unicode string.</returns>
    #define TO_WSTRING_PTR(in_str) (long)System.Runtime.InteropServices.Marshal.StringToHGlobalUni((##in_str##))

    /// <summary>
    /// Gets a pointer to a UTF-8 string.
    /// </summary>
    /// <param name="in_str">The UTF-8 string to get a pointer to.</param>
    /// <returns>A pointer to the input UTF-8 string.</returns>
    #define TO_U8STRING_PTR(in_str) (long)Helpers.StringToCoTaskMemUTF8((##in_str##))

    /// <summary>
    /// Gets an ANSI string from a pointer.
    /// </summary>
    /// <param name="in_ptr">The pointer to read an ANSI string from.</param>
    /// <returns>An ANSI string.</returns>
    #define FROM_STRING_PTR(in_ptr) System.Runtime.InteropServices.Marshal.PtrToStringAnsi((nint)(in_ptr))

    /// <summary>
    /// Gets a Unicode string from a pointer.
    /// </summary>
    /// <param name="in_ptr">The pointer to read a Unicode string from.</param>
    /// <returns>A Unicode string.</returns>
    #define FROM_WSTRING_PTR(in_ptr) System.Runtime.InteropServices.Marshal.PtrToStringUni((nint)(in_ptr))

    /// <summary>
    /// Gets a UTF-8 string from a pointer.
    /// </summary>
    /// <param name="in_ptr">The pointer to read a UTF-8 string from.</param>
    /// <returns>A UTF-8 string.</returns>
    #define FROM_U8STRING_PTR(in_ptr) Helpers.PtrToStringUTF8((nint)(in_ptr))


    /// <summary>
    /// Exposes a base field on the super class as a property
    /// </summary>
    /// <param name="TYPE">The field type.</param>
    /// <param name="NAME">The field name.</param>
    #define DEFINE_BASE_PROPERTY(TYPE, NAME) public TYPE NAME { get => Base.NAME; set => Base.NAME = value; }

    #define DEFINE_INTERFACE_PROPERTY(INTERFACE, TYPE, NAME) TYPE INTERFACE.NAME { get => NAME; set => NAME = value; }

    /// <summary>
    /// A struct representation of a `const char*`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public struct UnmanagedString
    {
        [FieldOffset(0)] public long pValue;
        
        public string Value
        {
            get
            {
                if (pValue == 0)
                    return string.Empty;

                return FROM_STRING_PTR(pValue);
            }

            set => pValue = TO_STRING_PTR(value);
        }

        public UnmanagedString(string in_value)
        {
            Value = in_value;
        }

        public static implicit operator UnmanagedString(string in_value)
        {
            return new UnmanagedString(in_value);
        }

        public static bool operator ==(UnmanagedString in_left, string in_right)
        {
            return in_left.Value == in_right;
        }

        public static bool operator !=(UnmanagedString in_left, string in_right)
        {
            return !(in_left == in_right);
        }

        public override bool Equals(object in_obj)
        {
            if (in_obj is string str)
                return Value == str;
            
            return base.Equals(in_obj);
        }

        public override int GetHashCode()
        {
            return (int)StringMapOperation.ComputeHash(Value);
        }

        public override string ToString()
        {
            return Value;
        }
    }

    [AttributeUsage(AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    public sealed class InternalNameAttribute : Attribute
    {
        public string InternalName { get; }

        public InternalNameAttribute(string in_internalName)
        {
            InternalName = in_internalName;
        }
    }

    /// <summary>
    /// Gets a list of indices where the input substring is found in a given string.
    /// </summary>
    /// <example>
    /// <code><![CDATA[
    /// Code
    /// //
    ///     #lib "Helpers"
    /// //
    /// {
    ///     string myString = "lots of uses of the word of";
    ///     
    ///     var substrs = Helpers.GetSubstringIndices(myString, "of");
    ///     
    ///     // This list should contain three entries.
    ///     // 0 - 5
    ///     // 1 - 13
    ///     // 2 - 25
    /// }
    /// ]]></code>
    /// </example>
    /// <param name="in_str">The string to find substrings in.</param>
    /// <param name="in_substr">The substring to search for.</param>
    /// <returns>A list of indices where a substring appears in the given string.</returns>
    public List<int> GetSubstringIndices(string in_str, string in_substr)
    {
        var indices = new List<int>();

        int i = 0;
        while ((i = in_str.IndexOf(in_substr, i)) != -1)
        {
            indices.Add(i);
            i += in_substr.Length;
        }

        return indices;
    }

    /// <summary>
    /// Gets a name from a InternalNameAttribute attached to a type.
    /// </summary>
    /// <param name="in_type">The type to get the attribute from.</param>
    /// <returns>A string representing the internal name of the input type.</returns>
    public static string GetInternalName(Type in_type)
    {
        var attr = (InternalNameAttribute)Attribute.GetCustomAttribute(in_type, typeof(InternalNameAttribute));

        return attr == null ? string.Empty : attr.InternalName;
    }

    // https://github.com/scripthookvdotnet/scripthookvdotnet/blob/main/source/core/StringMarshal.cs
    /*
        Copyright (C) 2015 crosire, kagikn

        This software is  provided 'as-is', without any express  or implied  warranty. In no event will the
        authors be held liable for any damages arising from the use of this software.
        Permission  is granted  to anyone  to use  this software  for  any  purpose,  including  commercial
        applications, and to alter it and redistribute it freely, subject to the following restrictions:

        1. The origin of this software must not be misrepresented; you must not claim that you  wrote the
            original  software. If you use this  software  in a product, an  acknowledgment in the product
            documentation would be appreciated but is not required.
        2. Altered source versions must  be plainly  marked as such, and  must not be  misrepresented  as
            being the original software.
        3. This notice may not be removed or altered from any source distribution.

        Changes;
            - 29/08/2023
                - (Hyper) renamed buffer
                - (Hyper) renamed functions to use uppercase "UTF8"
                - (Hyper) removed braces to compact code
                - (Hyper) removed unsafe clauses (HMM always uses unsafe code)
                - (Hyper) removed static modifiers

            - 20/09/2023
                - (Hyper) changed argument naming conventions
                - (Hyper) changed IntPtr to nint
                - (Hyper) changed string null check in StringToCoTaskMemUTF8 to use string.IsNullOrEmpty
    */
    /////////////////////////////////////////////////////////////////////////////////////////////////////////

    private static byte[] _bufferStringToCoTaskMemUTF8 = new byte[100];

    /// <summary>
    /// Gets a UTF-8 string from a memory location.
    /// </summary>
    /// <param name="in_ptr">The memory location where the UTF-8 string is.</param>
    /// <returns>A UTF-8 string.</returns>
    public string PtrToStringUTF8(nint in_ptr)
    {
        if (in_ptr == 0)
            return string.Empty;

        byte* data = (byte*)in_ptr;

        int len = 0;
        while (data[len] != 0)
            ++len;

        return PtrToStringUTF8(in_ptr, len);
    }

    /// <summary>
    /// Gets a fixed-length UTF-8 string from a memory location.
    /// </summary>
    /// <param name="in_ptr">The memory location where the UTF-8 string is.</param>
    /// <param name="in_length">The length of the UTF-8 string in memory.</param>
    /// <returns>A UTF-8 string.</returns>
    public string PtrToStringUTF8(nint in_ptr, int in_length)
    {
        if (in_length < 0)
            throw new ArgumentException(null, nameof(in_length));

        if (in_ptr == 0)
            return null;

        if (in_length == 0)
            return string.Empty;

        return Encoding.UTF8.GetString((byte*)in_ptr, in_length);
    }

    /// <summary>
    /// Creates a pointer to a UTF-8 string.
    /// </summary>
    /// <param name="in_str">The UTF-8 string to get a pointer for.</param>
    /// <returns>A pointer to the input UTF-8 string.</returns>
    public nint StringToCoTaskMemUTF8(string in_str)
    {
        if (string.IsNullOrEmpty(in_str))
            return 0;

        int byteCountUtf8 = Encoding.UTF8.GetByteCount(in_str);
        if (byteCountUtf8 > _bufferStringToCoTaskMemUTF8.Length)
            _bufferStringToCoTaskMemUTF8 = new byte[byteCountUtf8 * 2];

        Encoding.UTF8.GetBytes(in_str, 0, in_str.Length, _bufferStringToCoTaskMemUTF8, 0);

        nint dest = Marshal.AllocCoTaskMem(byteCountUtf8 + 1);
        if (dest == 0)
            throw new OutOfMemoryException();

        Marshal.Copy(_bufferStringToCoTaskMemUTF8, 0, dest, byteCountUtf8);
        
        ((byte*)dest)[byteCountUtf8] = 0;

        return dest;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////
}
Library "DeltaTime" by "Hyper"
{
    using System.Diagnostics;

    private static Stopwatch _frameTimer = new Stopwatch();

    private static float _deltaTime;

    private static int _deltaIndex;
    private static float _deltaSum;
    private static float[] _deltaSamples = new float[100];

    [LibraryInitializer]
    public void Init()
    {
        _frameTimer = Stopwatch.StartNew();
    }

    [LibraryUpdate]
    public void Update()
    {
        _deltaTime = (float)_frameTimer.Elapsed.TotalMilliseconds / 1000.0f;

        _frameTimer.Reset();
        _frameTimer.Start();
    }

    public float GetDeltaTime()
    {
        return _deltaTime;
    }

    public float GetDeltaTimeAverage()
    {
        _deltaSum -= _deltaSamples[_deltaIndex];
        _deltaSum += _deltaTime;
        
        _deltaSamples[_deltaIndex] = _deltaTime;

        if (++_deltaIndex == _deltaSamples.Length)
            _deltaIndex = 0;

        return _deltaSum / _deltaSamples.Length;
    }

    public double GetDeltaTimeMilliseconds()
    {
        return _frameTimer.Elapsed.TotalMilliseconds;
    }

    public float GetFrameRate(bool in_isRounded = true)
    {
        var result = 1.0f / _deltaTime;

        if (in_isRounded)
            result = (float)Math.Round(result);

        return result;
    }

    public float GetFrameRateAverage(bool in_isRounded = true)
    {
        var result = 1.0f / GetDeltaTimeAverage();

        if (in_isRounded)
            result = (float)Math.Round(result);

        return result;
    }
}
Library "Memory" by "Hyper & Sajid" 
{
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Text;

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr VirtualQuery(IntPtr lpAddress, ref MEMORY_BASIC_INFORMATION lpBuffer, UIntPtr dwLength);

    [StructLayout(LayoutKind.Sequential)]
    public struct MEMORY_BASIC_INFORMATION
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public uint AllocationProtect;
        public IntPtr RegionSize;
        public uint State;
        public uint Protect;
        public uint Type;
    }

    private static Dictionary<nint, List<byte>> _preservedMemory = new();

    public void Preserve(nint in_location, nint in_length, bool in_isPreservedOnce = true)
    {
        if (in_location == 0)
            return;

        if (in_isPreservedOnce)
        {
            if (_preservedMemory.ContainsKey(in_location))
                return;
        }
        else
        {
            if (_preservedMemory.ContainsKey(in_location))
                _preservedMemory.Remove(in_location);
        }
        
        List<byte> buffer = new();
        for (nint i = 0; i < in_length; i++)
            buffer.Add(Read<byte>(in_location + i));

        _preservedMemory.Add(in_location, buffer);
    }

    public void Preserve(long in_location, long in_length, bool in_isPreservedOnce = true)
    {
        Preserve((nint)in_location, (nint)in_length, in_isPreservedOnce);
    }

    public void Restore(nint in_location)
    {
        if (in_location == 0)
            return;

        if (!_preservedMemory.ContainsKey(in_location))
            return;

        nint i = 0;
        foreach (byte b in _preservedMemory[in_location])
        {
            WriteProtected<byte>(in_location + i, b);
            i++;
        }
    }

    public void Restore(long in_location)
    {
        Restore((nint)in_location);
    }

    public uint GetPageProtectFlags(nint in_location)
    {
        var memInfo = new MEMORY_BASIC_INFORMATION();

        if (VirtualQuery(in_location, ref memInfo, (UIntPtr)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION))) == IntPtr.Zero)
            return 1;

        return memInfo.Protect;
    }

    public bool IsAccessible(nint in_location)
    {
        // PAGE_NOACCESS
        if ((GetPageProtectFlags(in_location) & 1) != 0)
            return false;

        return true;
    }

    public nint ReadCall(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x01) + 0x05;
    }

    public long ReadCall(long in_location)
    {
        return (long)ReadCall((nint)in_location);
    }

    public nint ReadEffectiveAddress(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x03) + 0x07;
    }

    public long ReadEffectiveAddress(long in_location)
    {
        return (long)ReadEffectiveAddress((nint)in_location);
    }

    public enum JumpType : sbyte
    {
        Unknown = -1,
        ShortCond,
        NearJmp,
        NearCond,
        LongJmp
    }

    public JumpType ReadJumpOpcode(nint in_location)
    {
        JumpType result = JumpType.Unknown;

        if (in_location == 0)
            return result;

        byte opcode = Read<byte>(in_location);

        if ((opcode & 0xF0) == 0x70)
        {
            result = JumpType.ShortCond;
        }
        else
        {
            switch (opcode)
            {
                case 0xE3:
                case 0xEB:
                    result = JumpType.ShortCond;
                    break;

                case 0xE9:
                    result = JumpType.NearJmp;
                    break;

                case 0x0F:
                    result = JumpType.NearCond;
                    break;

                case 0xFF:
                    result = JumpType.LongJmp;
                    break;
            }
        }

        return result;
    }

    public JumpType ReadJumpOpcode(long in_location)
    {
        return ReadJumpOpcode((nint)in_location);
    }

    public nint ReadJump(nint in_location)
    {
        if (in_location == 0)
            return 0;

        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                return in_location + Read<byte>(in_location + 0x01) + 0x02;

            case JumpType.NearJmp:
                return in_location + Read<int>(in_location + 0x01) + 0x05;

            case JumpType.NearCond:
                return in_location + Read<int>(in_location + 0x02) + 0x06;

            case JumpType.LongJmp:
                return (nint)Read<long>(in_location + 0x06);
        }

        return 0;
    }

    public long ReadJump(long in_location)
    {
        return (long)ReadJump((nint)in_location);
    }

    public void WriteForceJump(nint in_location)
    {
        if (in_location == 0)
            return;
        
        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                WriteProtected<byte>(in_location, 0xEB);
                break;

            case JumpType.NearCond:
                WriteProtected<byte>(in_location, 0xE9);
                WriteProtected<int>(in_location + 0x01, Read<int>(in_location + 0x02) + 0x01);
                break;
        }
    }

    public void WriteForceJump(long in_location)
    {
        WriteForceJump((nint)in_location);
    }

    public nint ReadThunk(nint in_location, nint in_offset = 0)
    {
        return ReadJump(ReadCall(in_location) + in_offset);
    }

    public long ReadThunk(long in_location, long in_offset = 0)
    {
        return (long)ReadThunk((nint)in_location, (nint)in_offset);
    }

    public void WriteString(long in_location, string in_str, Encoding in_encoding)
    {
        WriteProtected<byte>(in_location, in_encoding.GetBytes(in_str));
    }

    public void WriteString(long in_location, string in_str)
    {
        WriteString(in_location, in_str, Encoding.ASCII);
    }

    public void PrintMemory<T>(IntPtr in_address, int in_rowCount) where T : unmanaged
    {
        for (int i = 0; i < in_rowCount * 16; i += 16)
        {
            Console.Write($"{(in_address + i).ToInt64():X16}: ");

            if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
            {
                for (int j = 0; j < 16; j++)
                    Console.Write($"{Read<T>(in_address + i + j):X2} ");
            }
            else if (typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
            {
                for (int j = 0; j < 16; j += 2)
                    Console.Write($"{Read<T>(in_address + i + j):X4} ");
            }
            else if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<T>(in_address + i + j):X8} ");
            }
            else if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<T>(in_address + i + j):X16} ");
            }
            else if (typeof(T) == typeof(float))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<float>(in_address + i + j)} ");
            }
            else if (typeof(T) == typeof(double))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<double>(in_address + i + j)} ");
            }

            Console.WriteLine();
        }
    }

    public void PrintMemory(IntPtr in_address, int in_rowCount)
    {
        PrintMemory<byte>(in_address, in_rowCount);
    }

    public static bool TryGetPointer<T>(void* in_pData, out T* out_pData) where T : unmanaged
    {
        out_pData = (T*)in_pData;

        return in_pData != null;
    }
    
    public struct Pointer<T> where T : unmanaged
    {
        public T* pData;

        public Pointer(ref T data)
        {
            fixed(T* dataPtr = &data)
            {
                pData = dataPtr;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Pointer(T* in_pData)
        {
            pData = in_pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsValid()
        {
            return pData != null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Ref()
        {
            return ref *pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T* Get()
        {
            return pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator bool(Pointer<T> self) => self.IsValid();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Pointer<T>(T* data) => new(data);

        public override string ToString() => $"0x{((long)pData):X}";
    }
}
Library "Bitwise" by "Hyper" 
{
    public long Set(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base | (in_isOffsetBitIndex ? (1L << in_offset) : in_offset);
    }

    public long Reset(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base & (in_isOffsetBitIndex ? ~(1L << in_offset) : in_offset);
    }

    public bool Test(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return (in_base & (in_isOffsetBitIndex ? (1L << in_offset) : in_offset)) != 0;
    }
}
Library "INI" by "Hyper"
{
    using System.Collections.Generic;
    using System.IO;
    
    public Dictionary<string, Dictionary<string, string>> Read(string path)
    {
        Dictionary<string, Dictionary<string, string>> result = new();

        if (!File.Exists(path))
            return result;

        using (StreamReader reader = new StreamReader(path))
        {
            string section = string.Empty;
            string line = string.Empty;

            // Add root section.
            result.Add(section, new Dictionary<string, string>());

            while ((line = reader.ReadLine()) != null)
            {
                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    section = line.Substring(1, line.Length - 2);
                    result.Add(section, new Dictionary<string, string>());
                    continue;
                }

                if (line.StartsWith(";") || line.StartsWith("#"))
                    continue;

                int delimiterIndex = line.IndexOf('=');

                if (delimiterIndex == -1)
                    continue;

                string key = line.Substring(0, delimiterIndex);
                string value = line.Substring(delimiterIndex + 1);

                if (value.StartsWith("\"") && value.EndsWith("\"") && value.Length > 1)
                    value = value.Substring(1, value.Length - 2);
                
                result[section].Add(key, value);
            }
        }

        return result;
    }

    public T Parse<T>(string in_value, T in_defaultValue)
    {
        T result = in_defaultValue;

        if (typeof(T) == typeof(string))
        {
            result = (T)(object)in_value;
        }
        else if (typeof(T) == typeof(bool))
        {
            if (bool.TryParse(in_value, out bool out_boolValue))
            {
                result = (T)(object)out_boolValue;
            }
            else
            {
                return (T)(object)(Parse<int>(in_value, (bool)(object)in_defaultValue ? 1 : 0) > 0);
            }
        }
        else if (typeof(T) == typeof(int))
        {
            if (int.TryParse(in_value, out int out_intValue))
                result = (T)(object)out_intValue;
        }
        else if (typeof(T) == typeof(double))
        {
            if (double.TryParse(in_value, out double out_doubleValue))
                result = (T)(object)out_doubleValue;
        }
        else if (typeof(T) == typeof(float))
        {
            if (float.TryParse(in_value, out float out_floatValue))
                result = (T)(object)out_floatValue;
        }

        return result;
    }

    public T GetField<T>(Dictionary<string, Dictionary<string, string>> in_ini, string in_section, string in_key, T in_defaultValue)
    {
        if (!in_ini.ContainsKey(in_section))
            return in_defaultValue;

        if (!in_ini[in_section].ContainsKey(in_key))
            return in_defaultValue;

        return Parse<T>(in_ini[in_section][in_key], in_defaultValue);
    }
}
Library "RTTI" by "Hyper"
{
    #lib "Memory"

    #define RESOLVE_RELATIVE_PTR(in_offset) (IntPtr.Size == 4 ? in_offset : (0x140000000 + in_offset))

    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Text;

    [DllImport("imagehlp.dll", CallingConvention = CallingConvention.StdCall)]
    private static extern uint UnDecorateSymbolName([MarshalAs(UnmanagedType.LPStr)] string name, byte[] outputString, uint maxStringLength, uint flags);

    [StructLayout(LayoutKind.Sequential)]
    public struct CompleteObjectLocator
    {
        public int Signature;
        public int VftableOffset;
        public int CtorDisplacementOffset;
        public int pTypeDescriptor;
        public int pClassHierarchyDescriptor;
        public int pObjectBase;

        public TypeDescriptor* GetTypeDescriptor()
        {
            return (TypeDescriptor*)RESOLVE_RELATIVE_PTR(pTypeDescriptor);
        }

        public ClassHierarchyDescriptor* GetClassHierarchyDescriptor()
        {
            return (ClassHierarchyDescriptor*)RESOLVE_RELATIVE_PTR(pClassHierarchyDescriptor);
        }

        public override string ToString()
            => $"const {GetTypeDescriptor()->GetName()}::`RTTI Complete Object Locator'";
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct TypeDescriptor
    {
        public void* pTypeInfo;
        public void* pRuntimeRef;
        
        public string GetName(bool in_isDemangled = true, IEnumerable<DemanglerFlags> in_demanglerFlags = null)
        {
            fixed (TypeDescriptor* pThis = &this)
            {
                var result = Marshal.PtrToStringAnsi((nint)((long)pThis + (IntPtr.Size == 4 ? 0x08 : 0x10)));

                if (string.IsNullOrEmpty(result))
                    return string.Empty;

                result = result.TrimStart('.');
                
                if (in_isDemangled)
                {
                    if (in_demanglerFlags == null)
                        in_demanglerFlags = new[] { RTTI.DemanglerFlags.NAME_ONLY };
                    
                    return Demangle(result, in_demanglerFlags);
                }
                else
                {
                    return result;
                }
            }
        }

        public string[] GetNamespaces()
        {
            return GetName().Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
        }

        public override string ToString()
            => $"class {GetName()} `RTTI Type Descriptor'";
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ClassHierarchyDescriptor
    {
        public int Signature;
        public int Attributes;
        public int BaseClassCount;
        public int pBaseClasses;

        public BaseClassDescriptor* GetBaseClass(int in_index)
        {
            if (in_index > BaseClassCount)
                return null;
                
            var ptr = *(int*)(RESOLVE_RELATIVE_PTR(pBaseClasses) + (in_index * 4));
            
            return (BaseClassDescriptor*)(RESOLVE_RELATIVE_PTR(ptr));
        }

        public override string ToString()
            => $"{GetBaseClass(0)->GetTypeDescriptor()->GetName()}::`RTTI Class Hierarchy Descriptor'";
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct BaseClassDescriptor
    {
        public int pTypeDescriptor;
        public int SubElementCount;
        public int MemberDisplacement;
        public int VftableDisplacement;
        public int DisplacementWithinVftable;
        public int BaseClassAttributes;
        public int pClassHierarchyDescriptor;

        public TypeDescriptor* GetTypeDescriptor()
        {
            return (TypeDescriptor*)RESOLVE_RELATIVE_PTR(pTypeDescriptor);
        }

        public ClassHierarchyDescriptor* GetClassHierarchyDescriptor()
        {
            return (ClassHierarchyDescriptor*)RESOLVE_RELATIVE_PTR(pClassHierarchyDescriptor);
        }

        public override string ToString()
            => $"{GetTypeDescriptor()->GetName()}::`RTTI Base Class Descriptor at ({MemberDisplacement}, {VftableDisplacement}, {DisplacementWithinVftable}, {BaseClassAttributes})'";
    }

    public CompleteObjectLocator* GetRuntimeInfoFromVftable(void* in_pVftable)
    {
        if (in_pVftable == null)
            return null;

        var runtimeInfoOffset = *(long*)((long)in_pVftable - IntPtr.Size);

        if (!Memory.IsAccessible((nint)runtimeInfoOffset))
            return null;
        
        return (CompleteObjectLocator*)runtimeInfoOffset;
    }

    public CompleteObjectLocator* GetRuntimeInfo(void* in_pClass)
    {
        return GetRuntimeInfoFromVftable((void*)*(long*)in_pClass);
    }

    public string GetClassName(void* in_pClass, bool in_isDemangled = true, IEnumerable<DemanglerFlags> in_demanglerFlags = null)
    {
        var pRuntimeInfo = RTTI.GetRuntimeInfo(in_pClass);

        if (pRuntimeInfo == null)
            return string.Empty;

        var pTypeDescriptor = pRuntimeInfo->GetTypeDescriptor();

        if (pTypeDescriptor == null)
            return string.Empty;
            
        return pTypeDescriptor->GetName(in_isDemangled, in_demanglerFlags);
    }

    public string[] GetClassNamespaces(void* in_pClass)
    {
        return GetClassName(in_pClass).Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
    }

    public string Demangle(string in_mangledName, IEnumerable<DemanglerFlags> in_flags)
    {
        var result = string.Empty;
        var flags = 0U;
        var demangledBytes = new byte[1024];

        foreach (var flag in in_flags)
            flags |= (uint)flag;

        while (true)
        {
            var resultLength = UnDecorateSymbolName
            (
                in_mangledName,
                demangledBytes,
                (uint)demangledBytes.Length,
                (uint)flags
            );

            if (resultLength == (demangledBytes.Length - 2))
            {
                demangledBytes = new byte[demangledBytes.Length * 2];
                continue;
            }
            else
            {
                int count = Array.IndexOf<byte>(demangledBytes, 0, 0);

                if (count < 0)
                    count = demangledBytes.Length;

                result = Encoding.ASCII.GetString(demangledBytes, 0, count);

                break;
            }
        }

        if (string.IsNullOrEmpty(result))
            return result;
        
        var namespaces = result.Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);

        if (namespaces.Length > 0)
        {
            var last = namespaces[namespaces.Length - 1];
            
            if (last.StartsWith("AV"))
                namespaces[namespaces.Length - 1] = last.Remove(0, 2);

            result = string.Join("::", namespaces);
        }

        return result;
    }

    public enum DemanglerFlags
    {
        /// <summary>
        /// Enable full undecoration.
        /// </summary>
        COMPLETE = 0x0000,

        /// <summary>
        /// Remove leading underscores from Microsoft keywords.
        /// </summary>
        NO_LEADING_UNDERSCORES = 0x0001,

        /// <summary>
        /// Disable expansion of Microsoft keywords.
        /// </summary>
        NO_MS_KEYWORDS = 0x0002,

        /// <summary>
        /// Disable expansion of return types for primary declarations.
        /// </summary>
        NO_FUNCTION_RETURNS = 0x0004,

        /// <summary>
        /// Disable expansion of the declaration model.
        /// </summary>
        NO_ALLOCATION_MODEL = 0x0008,

        /// <summary>
        /// Disable expansion of the declaration language specifier.
        /// </summary>
        NO_ALLOCATION_LANGUAGE = 0x0010,

        /// <summary>
        /// Disable expansion of Microsoft keywords on the this type for primary declaration.
        /// </summary>
        NO_MS_THISTYPE = 0x0020,

        /// <summary>
        /// Disable expansion of CodeView modifiers on the this type for primary declaration.
        /// </summary>
        NO_CV_THISTYPE = 0x0040,

        /// <summary>
        /// Disable all modifiers on the "this" type.
        /// </summary>
        NO_THISTYPE = 0x0060,

        /// <summary>
        /// Disable expansion of access specifiers for members.
        /// </summary>
        NO_ACCESS_SPECIFIERS = 0x0080,

        /// <summary>
        /// Disable expansion of throw-signatures for functions and pointers to functions.
        /// </summary>
        NO_THROW_SIGNATURES = 0x0100,

        /// <summary>
        /// Disable expansion of the static or virtual attribute of members.
        /// </summary>
        NO_MEMBER_TYPE = 0x0200,

        /// <summary>
        /// Disable expansion of the Microsoft model for user-defined type returns.
        /// </summary>
        NO_RETURN_UDT_MODEL = 0x0400,

        /// <summary>
        /// Undecorate 32-bit decorated names.
        /// </summary>
        P32_BIT_DECODE = 0x0800,

        /// <summary>
        /// Undecorate only the name for primary declaration. Returns [scope::]name. Does expand template parameters.
        /// </summary>
        NAME_ONLY = 0x1000,

        /// <summary>
        /// Do not undecorate function arguments.
        /// </summary>
        NO_ARGUMENTS = 0x2000,

        /// <summary>
        /// Do not undecorate special names, such as vtable, vcall, vector, metatype, and so on.
        /// </summary>
        NO_SPECIAL_SYMS = 0x4000
    }
}
Patch "Smooth Camera (v1.10.0.1)" in "Camera" by "Ahremic & Hyper" does "Replaces linear camera interpolation with a sigmoid solution, using Ken Perlin's ''Smoother Step'' second-order hermite polynomial." 
//
    static float value01 = 1.0f;
    static float value03 = 3.0f;
    static float value05 = 5.0f;
    static float value10 = 10.0f;
//
{
    // Linear coordinate interpolator
    WriteProtected<byte>(0x146506695, Assemble("mov edx, 0x60"));
    WriteProtected<byte>(0x1465066D2, Assemble("mov edx, 0x60; nop"));

    // Target Base interpolator
    WriteProtected<byte>(0x146506786, Assemble("mov edx, 0x230; nop"));
    WriteProtected<byte>(0x146506754, Assemble("mov edx, 0x230; nop"));
    WriteProtected<byte>(0x14650670A, Assemble("mov edx, 0x230"));

    // Base Ctor type A
    WriteAsmHook
    (
        "movss dword ptr [rdi + 0x220], xmm6",

        0x1400A6277,

        HookBehavior.After
    );

    // Base Ctor type B
    WriteAsmHook
    (
        "movss dword ptr [rdi + 0x220], xmm6",

        0x1464A5B29,

        HookBehavior.After
    );

    // Linear Ctor
    WriteAsmHook
    (
        "movss dword ptr [rdi + 0x50], xmm6",

        0x1400A5D30,

        HookBehavior.After
    );

    // Initialize our value in camera init/reset functions (whatever these are), just to be safe.

    // Base
    WriteAsmHook
    (
        "mov [rdi + 0x220], eax",

        0x1400A6A7A,

        HookBehavior.After
    );

    // Linear. This function can't use before/after because of a call being invoked, and a bug with how HMM interprets calls in x64 assembly, potentially.
    WriteAsmHook
    (
        $@"
            ; Prologue
            mov  [rsp + 8], rbx
            push rdi
            sub  rsp, 0x20
            mov  eax, [rcx + 0x20]
            mov  rdi, rcx

            ; Custom data
            mov  [rdi + 0x50], eax
        ",

        0x1400A6100,

        HookBehavior.Replace
    );

    // Smoother-step algorithm by Ken Perlin
    // https://en.wikipedia.org/wiki/Smoothstep
    fixed (float* pValue01 = &value01)
    fixed (float* pValue03 = &value03)
    fixed (float* pValue05 = &value05)
    fixed (float* pValue10 = &value10)
    {
        // Base cam update
        WriteAsmHook
        (
            $@"
                movss  xmm2, dword ptr [rcx + 0x220]
                xorps  xmm0, xmm0
                subss  xmm2, dword ptr [rdx]
                comiss xmm0, xmm2
                movss  dword ptr [rcx + 0x220], xmm2
                jb     jumpA
                mov    dword ptr [rcx + 0x220], 0
                xorps  xmm2, xmm2

            jumpA:
                movss  xmm3, dword ptr [rcx + 0x1F0]
                comiss xmm3, xmm0
                jbe    jumpB
                divss  xmm2, xmm3
                jmp    jumpC

            jumpB:
                mov    rax, {(long)pValue01}
                movss  xmm2, dword ptr [rax]

            jumpC:
                movaps xmm0, xmm2
                movaps xmm1, xmm2
                mov    rax, {(long)pValue03}
                mulss  xmm0, dword ptr [rax]
                addss  xmm1, xmm2
                mov    rax, {(long)pValue05}
                subss  xmm1, dword ptr [rax]
                mulss  xmm1, xmm0
                movaps xmm0, xmm2
                mulss  xmm0, xmm2
                mov    rax, {(long)pValue10}
                addss  xmm1, dword ptr [rax]
                mulss  xmm0, xmm2
                mulss  xmm1, xmm0
                mulss  xmm1, xmm3
                movss  dword ptr [rcx + 0x1F4], xmm1
                ret
            ",

            0x1400A6D20,

            HookBehavior.Replace
        );

        // Linear cam update
        WriteAsmHook
        (
            $@"
                movss  xmm2, dword ptr [rcx + 0x50]
                xorps  xmm0, xmm0
                subss  xmm2, dword ptr [rdx]
                comiss xmm0, xmm2
                movss  dword ptr [rcx + 0x50], xmm2
                jb     jumpA
                mov    dword ptr [rcx + 0x50], 0
                xorps  xmm2, xmm2

            jumpA:
                movss  xmm3, dword ptr [rcx + 0x20]
                comiss xmm3, xmm0
                jbe    jumpB
                divss  xmm2, xmm3
                jmp    jumpC

            jumpB:
                mov    rax, {(long)pValue01}
                movss  xmm2, dword ptr [rax]

            jumpC:
                movaps xmm0, xmm2
                movaps xmm1, xmm2
                mov    rax, {(long)pValue03}
                mulss  xmm0, dword ptr [rax]
                addss  xmm1, xmm2
                mov    rax, {(long)pValue05}
                subss  xmm1, dword ptr [rax]
                mulss  xmm1, xmm0
                movaps xmm0, xmm2
                mulss  xmm0, xmm2
                mov    rax, {(long)pValue10}
                addss  xmm1, dword ptr [rax]
                mulss  xmm0, xmm2
                mulss  xmm1, xmm0
                mulss  xmm1, xmm3
                movss  dword ptr [rcx + 0x24], xmm1
                ret
            ",

            0x1400A6140,

            HookBehavior.Replace
        );
    }
}
Patch "Disable Chaos Control Slow-Mo Music" in "Audio" by "brekko" does "Disables Chaos Control slowing the music down whilst active."
//
    #lib "Memory"
//
{
    Memory.WriteForceJump
    (
        /* v1.1.0.1:  0x14070158E */
        /* v1.10.0.0: 0x140724D0B */
        ScanSignature
        (
            "\x74\x66\x84\xC0\x0F\x85\x5E\x01\x00\x00",
            "xxxxxxxxxx"
        )
    );
}
Patch "Infinite Boost Gauge" in "Cheats" by "Hyper"
{
    // v1.1.0.0: 0x1406C1893
    // v1.1.0.1: 0x1406C1B43
    var sig = ScanSignature
    (
        "\x80\x3D\xCC\xCC\xCC\xCC\xCC\x4C\x8B\xAC\x24\x98\x00\x00\x00",
        "xx?????xxxxxxxx"
    );

    if (sig == 0)
        return;

    var gpInfiniteBoostGauge = sig + Read<int>(sig + 2) + 7;

    *(bool*)gpInfiniteBoostGauge = true;
}
Patch "Tighter Jump Rotation" in "Physics" by "Hyper" does "Allows for tighter mid-air control for more precise movements when jumping."
//
    #lib "Memory"

    static float _sensitivity = 0.05f;
//
{
    fixed (float* p_sensitivity = &_sensitivity)
    {
        // Jump Slow Sensitivity
        WriteAsmHook
        (
            $@"
                mov   rcx, {(long)p_sensitivity}
                mulss xmm2, dword ptr [rcx]
                mov   dword ptr [rsp + 0x58], 0x3F800000
            ",

            /* v1.1.0.0:  0x140648315 */
            /* v1.1.0.1:  0x1406485C5 */
            /* v1.10.0.0: 0x14066A594 */
            ScanSignature
            (
                "\xF3\x0F\x59\x15\xCC\xCC\xCC\xCC\xC7\x44\x24\x68\x00\x00\x80\x3F",
                "xxxx????xxxxxxxx"
            ),

            HookBehavior.Replace
        );

        // v1.10.0.0: 0x14066A673
        var sig = ScanSignature
        (
            "\x0F\x2F\x7B\x18\xF3\x0F\x10\x35",
            "xxxxxxxx"
        );

        if (sig == 0)
            return;

        var jumpAddr = Memory.ReadJump(sig + 12);

        if (jumpAddr == 0)
            return;

        // Jump Fast Sensitivity
        WriteAsmHook
        (
            $@"
                mov    rdx, {(long)p_sensitivity}
                movss  xmm6, dword ptr [rdx]
                comiss xmm7, dword ptr [rbx + 0x18]
                ja     exit
                mov    rdx, {jumpAddr}
                jmp    rdx
            exit:
            ",

            sig,

            HookBehavior.Replace
        );
    }
}
Patch "Tighter Jump Rotation for Doom Surf" in "Physics" by "Hyper" does "Allows for tighter mid-air control with Doom Surf for more precise movements when jumping."
//
    static float _sensitivity = 0.05f;
    static float _dsurfSteeringSpeedAir = 80.0f;
//
{
    fixed (float* p_sensitivity = &_sensitivity)
    fixed (float* p_dsurfSteeringSpeedAir = &_dsurfSteeringSpeedAir)
    {
        // Doom Surf Jump Sensitivity & Steering Speed
        WriteAsmHook
        (
            $@"
                mov   r12, {(long)p_dsurfSteeringSpeedAir}
                mov   r12d, dword ptr [r12]
                mov   dword ptr [r14 + 0x34], r12d
                movss xmm0, dword ptr [r14 + 0x34]
                mov   r12, {(long)p_sensitivity}
                mulss xmm0, dword ptr [r12]
            ",

            /* v1.1.0.0: 0x14068FCCC */
            /* v1.1.0.1: 0x14068FF7C */
            ScanSignature
            (
                "\xF3\x41\x0F\x10\x46\x34\xF3\x0F\x59\x05",
                "xxxxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}
Patch "Disable Decelerate Collision" in "Physics" by "Hyper" does "Disables the collision flag that kills all horizontal velocity when jumping."
{
    // v1.1.0.0: 0x1405F728F
    // v1.1.0.1: 0x1405F753F
    var sig = ScanSignature
    (
        "\x89\x41\x34\x8B\x42\x38\x89\x41\x38\x8B\x42\x3C\x89\x41\x3C\x0F\xB6\x42\x40\x88\x41\x40\x48\x8B\xC1",
        "xxxxxxxxxxxxxxxxxxxxxxxxx"
    );

    if (sig == 0)
        return;

    WriteAsmHook("and eax, 0xFFFFFDFF", sig, HookBehavior.After);
}
Patch "Tighter Jump Rotation for Doom Morph" in "Physics" by "Hyper" does "Allows for tighter mid-air control with Doom Morph for more precise movements when jumping."
//
    static float _sensitivity = 0.05f;
    static float _amoebaSteeringSpeed2 = 180.0f;
    static float _amoebaStartSteeringSpeed = 25.0f;
//
{
    fixed (float* p_sensitivity = &_sensitivity)
    fixed (float* p_amoebaSteeringSpeed2 = &_amoebaSteeringSpeed2)
    fixed (float* p_amoebaStartSteeringSpeed = &_amoebaStartSteeringSpeed)
    {
        // Doom Morph Jump Sensitivity
        WriteAsmHook
        (
            $@"
                comiss xmm12, dword ptr [r14 + 0x24]
                mov    rax, {(long)p_sensitivity}
                movss  xmm10, dword ptr [rax]
            ",

            /* v1.1.0.0: 0x140635D33 */
            /* v1.1.0.1: 0x140635FE3 */
            ScanSignature
            (
                "\x45\x0F\x2F\x66\x24\xF3\x44\x0F\x10\x15",
                "xxxxxxxxxx"
            ),

            HookBehavior.Replace
        );

        // Doom Morph Jump Steering Speed
        WriteAsmHook
        (
            $@"
                mov    rax, {(long)p_amoebaSteeringSpeed2}
                movss  xmm0, dword ptr [rax]
                movaps xmm1, xmm6
                mov    rax, {(long)p_amoebaStartSteeringSpeed}
                movss  xmm4, dword ptr [rax]
                movaps xmm2, xmm0
            ",

            /* v1.1.0.0: 0x140636020 */
            /* v1.1.0.1: 0x1406362D0 */
            ScanSignature
            (
                "\xF3\x0F\x10\x46\x0C\x0F\x28\xCE",
                "xxxxxxxx"
            ),

            HookBehavior.Replace
        );
    }
}
Patch "Tighter Drop Dash Rotation" in "Physics" by "Hyper" does
/*
Allows for tighter steering whilst rolling for more precise movement.

Notes;
- This requires the Restore Drop Dash code.
*/
//
    static float _brake = 2.5f;
    static float _steeringSpeed1 = 400.0f;
    static float _steeringSpeed2 = 200.0f;
//
{
    fixed (float* p_brake = &_brake)
    fixed (float* p_steeringSpeed1 = &_steeringSpeed1)
    fixed (float* p_steeringSpeed2 = &_steeringSpeed2)
    {
        WriteAsmHook
        (
            $@"
                mov r14, {(long)p_brake}
                mov r14d, dword ptr [r14]
                mov dword ptr [rax + 0x18], r14d
                mov r14, {(long)p_steeringSpeed1}
                mov r14d, dword ptr [r14]
                mov dword ptr [rax + 0x20], r14d
                mov r14, {(long)p_steeringSpeed2}
                mov r14d, dword ptr [r14]
                mov dword ptr [rax + 0x24], r14d
            ",

            /* v1.1.0.0: 0x140639E6A */
            /* v1.1.0.1: 0x14063A11A */
            ScanSignature
            (
                "\x4C\x8B\xF0\xF3\x44\x0F\x10\x58\x20",
                "xxxxxxxxx"
            ),

            HookBehavior.After
        );
    }

    // Disable turning delay.
    WriteNop
    (
        /* v1.1.0.0: 0x14068D4F0 */
        /* v1.1.0.1: 0x14068D7A0 */
        ScanSignature
        (
            "\x73\x19\x48\x8B\x47\x40",
            "xxxxxx"
        ),

        2
    );
}
Patch "Always Allow Boosting with Doom Surf" in "Gameplay" by "Hyper" does "Allows Shadow to boost with Doom Surf at any time, rather than once before a fraction of a second after activating the power."
//
    #lib "Memory"
//
{
    // v1.1.0.1: 0x1406920CC
    var sigIsInputPressed = ScanSignature
    (
        "\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x1B\x66\xC7\x86\xF6\x00\x00\x00\x00\x01",
        "x????xxxxxxxxxxxxx"
    );

    if (sigIsInputPressed == 0)
        return;

    // v1.1.0.1: 0x1406DE1E0
    var fpIsInputPressed = Memory.ReadCall(sigIsInputPressed);
    
    WriteAsmHook
    (
        $@"
            mov    edx, 3
            mov    rcx, rdi
            mov    r15, {fpIsInputPressed}
            call   r15
            test   al, al
            jz     exit
            mov    ecx, 0x3F800000              ; 1.0f
            movd   xmm0, ecx
            comiss xmm0, dword ptr [rsi + 0xD0] ; Check with time since activation.
            jnb    exit
            mov    dword ptr [rsi + 0xD0], 0
            mov    word ptr [rsi + 0xF6], 0x100
        exit:
            mov    edx, 0x1B5C66D2
            mov    rcx, qword ptr [rdi + 0x40]
        ",

        /* v1.1.0.1: 0x14069204E */
        ScanSignature
        (
            "\x45\x32\xFF\x0F\x57\xFF",
            "xxxxxx"
        ),

        HookBehavior.After
    );
}
Patch "Disable Ring Magnetism (experimental)" in "Gameplay" by "Hyper" does
/*
Disables rings spinning around and magnetising to the player upon collecting them.

Known issues;
- Rings that are attached to moving platforms will respawn immediately upon collecting them.
*/
{
    // ObjRing
    WriteNop
    (
        /* v1.1.0.0: 0x140403A31 */
        /* v1.1.0.1: 0x140403CE1 */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD3\x49\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x80\x8F\x50\x02\x00\x00\x02",
            "x????xxxxxxx????xxxxxxx"
        ),

        5
    );

    // ObjDroppedRing
    WriteNop
    (
        /* v1.1.0.0: 0x140400F3B */
        /* v1.1.0.1: 0x1404011EB */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD3\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x48\x8B\xD0\x48\x8B\xCF\xE8\xCC\xCC\xCC\xCC\x33\xD2",
            "x????xxxxxxx????x????xxxxxxx????xx"
        ),

        5
    );
}
Patch "Always Use Movie Shadow Skin (experimental)" in "Gameplay" by "Hyper & angryzor" does
/*
Always uses the Movie Shadow skin across the game.

Notes;
- This requires the Sonic the Hedgehog 3 Movie Pack DLC.

Known issues;
- All animations and cutscenes that are not used by the Tokyo mission will not be animated properly.
- Swing poles are unusable.
*/
//
    #lib "Memory"
//
{
    long[] addrs =
    {
        /* v1.10.0.0: 0x1406836D9 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x44\x0F\xB6\xE0\x3C\x02", "x????xxxxxx"),                     // Load model resources.
        /* v1.10.0.0: 0x14011785D */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x88\x85\x40\x01\x00\x00", "x????xxxxxx"),                     // Load model.
        /* v1.10.0.0: 0x1400FF474 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x0F\xBE\xD0\x33\xC9", "x????xxxxx"),                          // Load model.
        /* v1.10.0.0: 0x140180D11 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x3C\x02\x0F\x85\xBC\x01\x00\x00", "x????xxxxxxxx"),           // Load misc. resources.
        /* v1.10.0.0: 0x140180EE0 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x3C\x02\x0F\x85\xFC\x05\x00\x00", "x????xxxxxxxx"),           // Load voice resources.
        /* v1.10.0.0: 0x14A93E2F3 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x31\xDB\x3C\x02\x0F\x85\x80\x00\x00\x00", "x????xxxxxxxxxx"), // Load effects.
        /* v1.10.0.0: 0x1407EB9AB */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x84\xC0\x41\x0F\x95\xC7", "x????xxxxxx"),                     // Load stage select model.
        /* v1.10.0.0: 0x14B5ACCE4 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x66\x89\x0D\xCC\xCC\xCC\xCC\x3C\x01", "x????xxx????xx"),      // Load eye bones.
        /* v1.10.0.0: 0x14060DC48 */ ScanSignature("\xE8\xCC\xCC\xCC\xCC\x88\x45\x67\xC6\x45\x77\x01", "x????xxxxxxx")                 // Load info.
    };

    foreach (var addr in addrs)
        WriteProtected<byte>(addr, Assemble("mov al, 2; nop; nop; nop"));
    
    // Force load Movie Shadow UI and sound resources.
    WriteNop
    (
        /* v1.10.0.0: 0x1401806D0 */
        ScanSignature
        (
            "\x0F\x84\x13\x0E\x00\x00\x49\x8B\xCE",
            "xxxxxxxxx"
        ),

        6
    );
    
    // Disable Movie Shadow grind rail code.
    Memory.WriteForceJump
    (
        /* v1.10.0.0: 0x1406F10CA */
        ScanSignature
        (
            "\x0F\x84\x38\x01\x00\x00\x48\x8D\x54\x24\x30",
            "xxxxxxxxxxx"
        )
    );

    // Disable Movie Shadow Doom Power restrictions (angryzor).
    Memory.WriteForceJump
    (
        /* v1.10.0.0: 0x14060E211 */
        ScanSignature
        (
            "\x75\x55\x45\x33\xC0",
            "xxxxx"
        )
    );
}
Patch "Drop Dash on Double Jump" in "Gameplay" by "Hyper" does
/*
Allows the player to drop dash immediately after double jumping, making it require only two presses.

Notes;
- This requires the Restore Drop Dash code.
*/
{
    // v1.1.0.0:  0x14C5D9E0E
    // v1.1.0.1:  0x14B40269B
    // v1.10.0.0: 0x14AC7786A
    // v1.10.0.1: 0x14A7AE010
    var sig = ScanSignature
    (
        "\x74\x33\x48\x89\xD9\xE8",
        "xxxxxx"
    );

    if (sig == 0)
        return;
    
    WriteNop(sig, 2);
    WriteProtected<byte>(sig + 0x0F, 0xEB);
}
Patch "Disable Chaos Control Timer Freeze" in "Gameplay" by "brekko" does "Disables Chaos Control freezing the timer whilst active."
{
    WriteNop
    (
        /* v1.1.0.0: 0x140176515 */
        /* v1.1.0.1: 0x1401767C5 */
        ScanSignature
        (
            "\x0F\xB6\xA8\xE8\x00\x00\x00",
            "xxxxxxx"
        ),

        7
    );
}
Code "Restore Drop Dash" in "Gameplay" by "Hyper & Sora" does
/*
Restores the drop dash ability from Sonic Frontiers.

Notes;
- Drop Dash is not available whilst Doom Wing is active.
- Drop Dash is not available whilst in auto run sections.
- Drop Dash is not affected by the pollution Doom Morph uses to get around.
*/
//
    #include "Helpers" noemit

    #lib "GameManager"
    #lib "Memory"

    #import "GOComponents"

    static bool _isInitialised = false;
    static bool _isDropDashGrounded = false;
    static bool _isSideView = false;
//
{
    if (!_isInitialised)
    {
        // v1.1.0.0:  0x1406E8890
        // v1.1.0.1:  0x1406E8B40
        // v1.10.0.0: 0x14070C120
        // v1.10.0.1: 0x14070C140
        var fpPlaySound = Memory.ReadCall
        (
            /* v1.1.0.1:  0x14B402632 */
            /* v1.10.0.0: 0x14AC77801 */
            /* v1.10.0.1: 0x14A7ADFA8 */
            ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x8F\xE8\x00\x00\x00\x48\x89\xC2",
                "x????xxxxxxxxxx"
            )
        );

        // v1.1.0.0: 0x1406E13D0
        // v1.1.0.1: 0x1406E1680
        var fpDSurfTransition = ScanSignature
        (
            "\x48\x89\x5C\x24\x10\x48\x89\x7C\x24\x18\x4C\x89\x74\x24\x20\x55\x48\x8D\x6C\x24\xA9\x48\x81\xEC\xF0",
            "xxxxxxxxxxxxxxxxxxxxxxxxx"
        );

        // Force Drop Dash flag in BlackboardStatus.
        WriteAsmHook
        (
            $@"
                push rax
                mov  rdx, qword ptr [rbx + 0x28]        ; RDX = BlackboardStatus
                mov  rax, 0x0100000000000000
                test qword ptr [rdx + 0x40], rax        ; Check Doom Wing flag
                jz   enable
                mov  rax, 0xFFFFFFFFFDFFFFFF
                and  qword ptr [rdx + 0x30], rax        ; Disable Drop Dash flag
                jmp  exit
            enable:
                or   qword ptr [rdx + 0x30], 0x02000000 ; Enable Drop Dash flag
            exit:
                pop  rax
            ",

            /* v1.1.0.0:  0x14C5D9C78 */
            /* v1.1.0.1:  0x14B4024F2 */
            /* v1.10.0.0: 0x14AC776DB */
            ScanSignature
            (
                "\x0F\x28\xC1\x0F\xC6\xC1\x99\xF3\x0F\x58\xC8\x0F\xC6\xC0\x55\xF3\x0F\x58\xC8\x41\x0F\x2F\xC8\x0F\x47\xD0",
                "xxxxxxxxxxxxxxxxxxxxxxxxxx"
            ),

            HookBehavior.After
        );

        // Populate charge sound.
        WriteAsmHook
        (
            $@"
                mov r8, {TO_STRING_PTR("sd_doomspower")}
            ",

            /* v1.1.0.0: 0x14C5D9D8F */
            /* v1.1.0.1: 0x14B402623 */
            ScanSignature
            (
                "\x4C\x8D\x05\xCC\xCC\xCC\xCC\x48\x89\xDA\x48\x8D\x4C\x24\x70",
                "xxx????xxxxxxxx"
            ),

            HookBehavior.Before
        );

        // Populate release sound.
        WriteAsmHook
        (
            $@"
                mov  r8, {TO_STRING_PTR("sd_wing_airboost")}
                mov  rdx, rsi
                lea  rcx, qword ptr [rsp + 0x70]
                mov  rax, {fpPlaySound}
                call rax
                mov  r8, {TO_STRING_PTR("sd_chaos_spear_fire")}
                mov  rdx, rsi
                lea  rcx, qword ptr [rsp + 0x70]
                mov  rax, {fpPlaySound}
                call rax
                mov  r8, {TO_STRING_PTR("sd_doomspower")}
                mov  rdx, rsi
                lea  rcx, qword ptr [rsp + 0x70]
            ",

            /* v1.1.0.0: 0x14068D2D8 */
            /* v1.1.0.1: 0x14068D588 */
            ScanSignature
            (
                "\x4C\x8D\x05\xCC\xCC\xCC\xCC\x48\x8B\xD6\x48\x8D\x4C\x24\x70\xE8\xCC\xCC\xCC\xCC\x48\x8D\x8D\xE0\x00\x00\x00\x48\x8B\xD0\xE8\xCC\xCC\xCC\xCC\xB2\x01",
                "xxx????xxxxxxxxx????xxxxxxxxxxx????xx"
            ),

            HookBehavior.Replace
        );

        fixed (bool* p_isDropDashGrounded = &_isDropDashGrounded)
        fixed (bool* p_isSideView = &_isSideView)
        {
            // v1.1.0.0:  0x140639BB4
            // v1.1.0.1:  0x140639E64
            // v1.10.0.0: 0x14065C034
            var sigDropDashAirPosture = ScanSignature
            (
                "\x0F\x29\xB4\x24\x80\x00\x00\x00\x48\x8D\x54\x24\x20\x0F\x10\xB3\x00\x01\x00\x00",
                "xxxxxxxxxxxxxxxxxxxx"
            );

            // v1.1.0.1: 0x14063A090
            var fpDropDashGroundPosture = Memory.ReadCall
            (
                /* v1.1.0.1: 0x140639E5A */
                ScanSignature
                (
                    "\xE8\xCC\xCC\xCC\xCC\xE9\x03\x01\x00\x00\x0F\x29\xB4\x24\x80\x00\x00\x00",
                    "x????xxxxxxxxxxxxx"
                )
            );

            // Fix 2D rolling and Doom Surf transitions.
            WriteAsmHook
            (
                $@"
                    ; Preserve grounded flag.
                    mov    rdx, {(long)p_isDropDashGrounded}
                    mov    byte ptr [rdx], al

                    ; Call Doom Surf transition method.
                    xor    dl, dl
                    mov    rcx, qword ptr [rsi + 0x18]  ; RCX = PlayerPosture->PlayerPostureContext
                    mov    rcx, qword ptr [rcx + 0x10]  ; RCX = PlayerPosture->PlayerPostureContext->Player
                    mov    rcx, qword ptr [rcx + 0x2D0] ; RCX = PlayerPosture->PlayerPostureContext->Player->PlayerContext
                    mov    rax, {fpDSurfTransition}
                    call   rax

                    ; Restore grounded flag (this is fucking dirty, but push/pop doesn't work here).
                    mov    rax, {(long)p_isDropDashGrounded}
                    mov    al, byte ptr [rax]

                    ; If grounded, jump to ground posture.
                    test   al, al
                    jnz    doGroundPosture

                    ; Otherwise, jump to air posture.
                    mov    rax, {sigDropDashAirPosture}
                    jmp    rax

                doGroundPosture:
                    ; Don't do ground posture if we're in 2D.
                    mov    rcx, {(long)p_isSideView}
                    cmp    byte ptr [rcx], 0
                    jnz    exit

                    ; Call ground posture method.
                    movaps xmm1, xmm7
                    mov    rcx, rsi
                    mov    rax, {fpDropDashGroundPosture}
                    call   rax

                exit:
                ",

                /* v1.1.0.1: 0x140639E50 */
                ScanSignature
                (
                    "\x84\xC0\x74\x10\x0F\x28\xCF\x48\x8B\xCE",
                    "xxxxxxxxxx"
                ),

                HookBehavior.Replace
            );

            // Force minDashSpeed to minDashSpeedMax in 3D.
            WriteAsmHook
            (
                $@"
                    mov   rcx, {(long)p_isSideView}
                    cmp   byte ptr [rcx], 0
                    jnz   exit
                    mov   ecx, dword ptr [rbx + 0x08]
                    mov   dword ptr [rbx + 0x04], ecx
                exit:
                ",

                /* v1.1.0.1:  0x14BC07C91 */
                /* v1.10.0.0: 0x14B37F601 */
                ScanSignature
                (
                    "\xF3\x0F\x10\x53\x08\x48\x8D\x54\x24\x30",
                    "xxxxxxxxxx"
                ),

                HookBehavior.After
            );
        }

        _isInitialised = true;
    }

    var pPlayer = GameManager.GetGameObject("Shadow");

    if (pPlayer == null)
        return;

    var pGOCPlayerParameter = pPlayer->GetGOC<GOCPlayerParameter>();

    if (pGOCPlayerParameter == null)
        return;
        
    _isSideView = pGOCPlayerParameter->CurrentModePackageType == GOCPlayerParameter.ModePackageType.SideView;
}
Patch "Always Use Homing Attack (experimental)" in "Gameplay" by "Hyper" does
/*
Uses Homing Attack instead of Chaos Attack for Shadow's main airborne attack.

Known issues;
- Many enemies lack homing impact sounds, resulting in the attack being rather quiet.
- Shadow can no longer kick Black Arms enemies into the air.
- Shadow can no longer teleport through barriers to reach enemies.
*/
{
    WriteNop
    (
        /* v1.1.0.0:  0x1406E2449 */
        /* v1.1.0.1:  0x1406E26F9 */
        /* v1.10.0.0: 0x140705DD9 */
        ScanSignature
        (
            "\x75\x45\x48\x8B\xCB",
            "xxxxx"
        ),
        
        2
    );
}
Patch "Disable HUD" in "UI" by "Hyper"
{
    // Disable main display.
    WriteProtected<byte>
    (
        /* v1.1.0.0: 0x140746130 */
        /* v1.1.0.1: 0x1407463E0 */
        ScanSignature
        (
            "\x48\x89\x5C\x24\x10\x48\x89\x74\x24\x18\x48\x89\x7C\x24\x20\x55\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\x6C\x24\xC9\x48\x81\xEC\xC0\x00\x00\x00\x48\x8B",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        0xC3
    );

    // Disable White Space item info display.
    WriteProtected<byte>
    (
        /* v1.1.0.0: 0x1407B1B70 */
        /* v1.1.0.1: 0x1407B1E40 */
        ScanSignature
        (
            "\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x48\x89\x7C\x24\x18\x55\x41\x56\x41\x57\x48\x8D\x6C\x24\xB9\x48\x81\xEC\xB0\x00\x00\x00\x48\x8B\xD9\x48\xC7\x45\xE7",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        0xC3
    );
}
Code "Disable Result UI" in "UI" by "Hyper" does
/*
Disables the UI in the results screen.

Notes;
- This does not affect challenge acts.
*/
//
    #lib "GameManager"

    #import "GOComponents"
//
{
    var pUIResult = GameManager.GetGameObject("UIResult");
    var pUIResultInputHelp = GameManager.GetGameObject("UIResultInputHelp");

    if (pUIResult == null || pUIResultInputHelp == null)
        return;

    var pUIResultGOCSprite = pUIResult->GetGOC<GOCSprite>();
    var pUIResultInputHelpGOCSprite = pUIResultInputHelp->GetGOC<GOCSprite>();

    if (pUIResultGOCSprite == null || pUIResultInputHelpGOCSprite == null)
        return;

    pUIResultGOCSprite->Flags = 1;
    pUIResultInputHelpGOCSprite->Flags = 1;
}
Patch "Always Run in the Background" in "System" by "NM & Hyper" does "Stops the game from pausing when the window is unfocused."
//
    #lib "Memory"
//
{
    Memory.WriteForceJump
    (
        /* v1.1.0.0: 0x140A21D27 */
        /* v1.1.0.1: 0x140A220F7 */
        ScanSignature
        (
            "\x75\x4A\xC0\xE8\x03",
            "xxxxx"
        )
    );
}
Patch "Disable Keyboard Input" in "System" by "Hyper" does "Disables input from the keyboard."
//
    #lib "Memory"
//
{
    Memory.WriteForceJump
    (
        /* v1.1.0.0: 0x140C1C98F */
        /* v1.1.0.1: 0x140C1CC5F */
        ScanSignature
        (
            "\x0F\x84\x98\x00\x00\x00\x48\x8B\xB3\xB0\x01\x00\x00",
            "xxxxxxxxxxxxx"
        )
    );
}
Patch "Disable Telemetry" in "System" by "Hyper" does
/*
Prevents the game from sending telemetry and crash data to SEGA.

Notes;
- Crash dumps are moved to ''%LOCALAPPDATA%/CrashDumps''
- The data that's sent can include, but is not limited to;
  - CPU name
  - RAM
  - OS product version
  - motherboard information
*/
//
    #lib "Memory"
//
{
    // Disable hardware telemetry.
    Memory.WriteForceJump
    (
        /* v1.1.0.0: 0x1407F740C */
        /* v1.1.0.1: 0x1407F76DC */
        ScanSignature
        (
            "\x0F\x85\xDC\x10\x00\x00",
            "xxxxxx"
        )
    );

    // Disable logger thread.
    WriteNop
    (
        /* v1.1.0.0: 0x1407FBB03 */
        /* v1.1.0.1: 0x1407FBDD3 */
        ScanSignature
        (
            "\x74\x0D\xB0\x01\x48\x8B\x74\x24\x70",
            "xxxxxxxxx"
        ),
        
        2
    );

    // Disable crashpad.
    WriteAsmHook
    (
        $@"
            add rsp, 0x28
            ret
        ",

        /* v1.1.0.0: 0x146B55395 */
        /* v1.1.0.1: 0x1467CB756 */
        ScanSignature
        (
            "\x84\xC0\x74\x09\x48\x83\xC4\x28",
            "xxxxxxxx"
        ),

        HookBehavior.Replace
    );
}
Code "Disable Mouse Input" in "System" by "Hyper" does 
/*
Disables input from the mouse and unhooks the cursor from the game window.

Notes;
- This is mainly useful for debugging, to prevent the game stealing focus from debuggers (e.g. Cheat Engine) when modal windows are opened.
*/
//
    #lib "Memory"

    [System.Runtime.InteropServices.DllImport("user32.dll")]
    static extern int ShowCursor(bool bShow);

    static bool _isInitialised = false;
//
{
    /* There's way too many calls to this in the game,
       I'm just gonna force ShowCursor() every frame. */
    ShowCursor(true);

    if (_isInitialised)
        return;

    // Disable pointing for menus.
    Memory.WriteForceJump
    (
        /* v1.1.0.0:  0x140C1D823 */
        /* v1.1.0.1:  0x140C1DAF3 */
        /* v1.10.0.0: 0x140C47EB3 */
        ScanSignature
        (
            "\x0F\x85\x6A\x01\x00\x00\x48\x89\x68\x10",
            "xxxxxxxxxx"
        )
    );

    // Disable mouse axis mapping.
    WriteProtected<byte>
    (
        /* v1.1.0.0: 0x140C1CFA0 */
        /* v1.1.0.1: 0x140C1D270 */
        ScanSignature
        (
            "\x81\xC2\x00\x00\xFC\xFF\x83\xFA\x0C",
            "xxxxxxxxx"
        ),

        Assemble("xorps xmm0, xmm0; ret")
    );

    // Disable mouse cursor hook.
    WriteNop
    (
        /* v1.1.0.0: 0x140C0BDF8 */
        /* v1.1.0.1: 0x140C0C0C8 */
        ScanSignature
        (
            "\xFF\x15\xCC\xCC\xCC\xCC\x8B\x97\xD0\x00\x00\x00",
            "xx????xxxxxx"
        ),

        6
    );

    // Disable mouse cursor clipping.
    WriteNop
    (
        /* v1.1.0.0: 0x152D322D2 */
        /* v1.1.0.1: 0x1508E0D44 */
        ScanSignature
        (
            "\xFF\x15\xCC\xCC\xCC\xCC\x48\x83\xC4\x38\xC3\x31\xC9",
            "xx????xxxxxxx"
        ),

        6
    );

    // Disable mouse cursor position override on focus change.
    WriteNop
    (
        /* v1.1.0.0: 0x140C0BF2C */
        /* v1.1.0.1: 0x140C0C1FC */
        ScanSignature
        (
            "\xFF\x15\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\x48\x8B\x48\x28\x48\x8B\x49\x10",
            "xx????x????xxxxxxxx"
        ),

        6
    );

    // Disable mouse cursor position override on foreground window change.
    WriteNop
    (
        /* v1.1.0.0: 0x140A2267B */
        /* v1.1.0.1: 0x140A22A4B */
        ScanSignature
        (
            "\xFF\x15\xCC\xCC\xCC\xCC\xB2\x01\x48\x8B\xCB",
            "xx????xxxxx"
        ),

        6
    );

    _isInitialised = true;
}
Patch "Boot Directly to Title" in "System" by "Hyper"
{
    WriteNop
    (
        /* v1.1.0.0:  0x1407656F9 */
        /* v1.1.0.1:  0x1407659A9 */
        /* v1.10.0.0: 0x14078C648 */
        ScanSignature
        (
            "\x75\x08\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x81\xC4\x48\x0E\x00\x00",
            "xxxxxx????xxxxxxx"
        ),
        
        2
    );
}
Library "Collections" by "Sajid & Hyper"
{
    #import "Allocators"

    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;
    using System.Text;

    #define MAKE_BITSET_TYPE(NAME, TYPE) \
        public struct NAME \
        { \
            public TYPE Value; \
\
            public void Reset() \
            { \
                Value = 0; \
            } \
\
            public void Reset(TYPE in_bitIndex) \
            { \
                Value &= (TYPE)(~((TYPE)1 << (int)in_bitIndex)); \
            } \
\
            public void Flip(TYPE in_bitIndex) \
            { \
                Value ^= (TYPE)(((TYPE)1 << (int)in_bitIndex)); \
            } \
\
            public void Set() \
            { \
                Value = TYPE.MaxValue; \
            } \
\
            public void Set(TYPE in_bitIndex) \
            { \
                Value |= (TYPE)(((TYPE)1 << (int)in_bitIndex)); \
            } \
\
            public void Set(TYPE in_bitIndex, bool in_isEnabled) \
            { \
                if (in_isEnabled) \
                { \
                    Set(in_bitIndex); \
                } \
                else \
                { \
                    Reset(in_bitIndex); \
                } \
            } \
\
            public bool Test(TYPE in_bitIndex) \
            { \
                return (Value & (TYPE)(((TYPE)1 << (int)in_bitIndex))) != 0; \
            } \
        }
    
    MAKE_BITSET_TYPE(BitSet8, byte);
    MAKE_BITSET_TYPE(BitSet16, ushort);
    MAKE_BITSET_TYPE(BitSet32, uint);
    MAKE_BITSET_TYPE(BitSet64, ulong);

    private readonly nint SIGN_BIT = (nint)((1u << ((sizeof(nint) * sizeof(byte)) - 1)));
    
    /// <summary>
    /// A struct representation of `csl::ut::MoveArray<T>`.
    /// </summary>
    public struct MoveArray<T> : IEnumerable<T> where T : unmanaged
    {
        public T* pBuffer;
        public int Length;
        public int Capacity;
        public IAllocator* pAllocator;
        
        public int Count => Length;    

        public ref T this[int in_index]
        {
            get => ref pBuffer[in_index];
        }

        private bool IsInplace()
        {
            return (Capacity & SIGN_BIT) != 0;
        }
        
        public void Reserve(int in_length)
        {
            if (in_length <= Capacity)
                return;

            var newLength = sizeof(T) * in_length;
            var pNewBuffer = pAllocator->Alloc()(pAllocator, newLength, 16);

            if (pBuffer != null)
                Buffer.MemoryCopy(pBuffer, (T*)(long)pNewBuffer, newLength, newLength);

            if (!IsInplace())
                pAllocator->Free()(pAllocator, pBuffer);

            Capacity = in_length;
            pBuffer = (T*)(long)pNewBuffer;
        }

        public void Resize(int in_length)
        {
            Reserve(in_length);

            Length = in_length;
        }

        public void Add(T in_item)
        {
            Length++;

            if (Length > Capacity)
                Reserve(Length * 2);

            pBuffer[Length - 1] = in_item;
        }

        public void RemoveAt(int in_index)
        {
            if (in_index > Length)
                return;

            pBuffer[in_index] = pBuffer[in_index + 1];
            Length--;
        }

        public void Remove(T in_item)
        {
            var index = IndexOf(in_item);

            if (index != -1)
                RemoveAt(index);
        }

        public void Clear()
        {
            Length = 0;
        }

        public int IndexOf(T in_item)
        {
            for (int i = 0; i < Length; i++)
            {
                if (this[i].Equals(in_item))
                    return i;
            }

            return -1;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (var i = 0; i < Count; i++)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public List<T> ToList()
        {
            var l = new List<T>();
            
            foreach (var e in this)
                l.Add(e);

            return l;
        }

        public override string ToString()
        {
            if (typeof(T) == typeof(byte))
                return Encoding.ASCII.GetString(ToList().Select(x => (byte)(object)x).ToArray());

            return base.ToString();
        }
    }

    /// <summary>
    /// A struct representation of `csl::ut::ObjectMoveArray<T>`.
    /// </summary>
    public struct ObjectMoveArray<T> : IEnumerable<T> where T : unmanaged
    {
        public T* pBuffer;
        public nint Length;
        public nint Capacity;
        public IAllocator* pAllocator;
        
        public nint Count => Length;    

        public ref T this[nint in_index]
        {
            get => ref pBuffer[in_index];
        }

        private bool IsInplace()
        {
            return (Capacity & SIGN_BIT) != 0;
        }
        
        public void Reserve(nint in_length)
        {
            if (in_length <= Capacity)
                return;

            var newLength = sizeof(T) * in_length;
            var pNewBuffer = pAllocator->Alloc()(pAllocator, newLength, 16);

            if (pBuffer != null)
                Buffer.MemoryCopy(pBuffer, (T*)(long)pNewBuffer, newLength, newLength);

            if (!IsInplace())
                pAllocator->Free()(pAllocator, pBuffer);

            Capacity = in_length;
            pBuffer = (T*)(long)pNewBuffer;
        }

        public void Add(T in_item)
        {
            Length++;

            if (Length > Capacity)
                Reserve(Length * 2);

            pBuffer[Length - 1] = in_item;
        }

        public void RemoveAt(nint in_index)
        {
            if (in_index > Length)
                return;

            pBuffer[in_index] = pBuffer[in_index + 1];
            Length--;
        }

        public void Remove(T in_item)
        {
            var index = IndexOf(in_item);

            if (index != -1)
                RemoveAt(index);
        }

        public void Clear()
        {
            Length = 0;
        }

        public nint IndexOf(T in_item)
        {
            for (nint i = 0; i < Length; i++)
            {
                if (this[i].Equals(in_item))
                    return i;
            }

            return -1;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (var i = 0; i < Count; i++)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public List<T> ToList()
        {
            var l = new List<T>();
            
            foreach (var e in this)
                l.Add(e);

            return l;
        }
    }

    /// <summary>
    /// A custom `System.Collections.Generic.List<T>` where items are added and retrieved like a stack.
    /// </summary>
    public class StackList<T> : List<T>
    {
        private int _capacity;

        public StackList(int in_capacity)
        {
            _capacity = in_capacity;
        }

        /// <summary>
        /// Adds an item to the top of the stack.
        /// </summary>
        /// <param name="in_item">The item to add.</param>
        public new void Add(T in_item)
        {
            if (Count >= _capacity)
            {
                RemoveAt(Count - 1);
            }

            Insert(0, in_item);
        }

        /// <summary>
        /// Gets an item from any index in the stack.
        /// </summary>
        /// <param name="in_index">The index to get the item from in the stack.</param>
        /// <returns>The item in the stack at the requested index.</returns>
        public T GetItemAt(int in_index)
        {
            if (Count == 0)
                return default;

            if (in_index >= Count)
            {
                return this[Count - 1];
            }

            return this[in_index];
        }

        /// <summary>
        /// Adds an item to the top of the stack.
        /// </summary>
        /// <param name="in_item">The item to add.</param>
        public void Push(T in_item)
        {
            Add(in_item);
        }

        /// <summary>
        /// Gets an item from the top of the stack and removes it.
        /// </summary>
        /// <returns>The item at the top of the stack.</returns>
        public T Pop()
        {
            T item = GetItemAt(0);

            RemoveAt(0);

            return item;
        }

        /// <summary>
        /// Gets the item at the top of the stack.
        /// </summary>
        /// <returns>The item at the top of the stack.</returns>
        public T Peek()
        {
            return GetItemAt(0);
        }
    }
}
Library "GameService" by "Hyper & Sajid" 
{
    #lib "GameManager"
    #lib "Helpers"
    
    using System.Runtime.InteropServices;

    /// <summary>
    /// A struct representation of `hh::game::GameService`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x70)]
    public struct Data
    {
        /// <summary>
        /// A pointer to an instance of `app::GameManager`.
        /// </summary>
        [FieldOffset(0x30)] public GameManager.Data* pGameManager;

        /// <summary>
        /// A pointer to an instance of `GameServiceStaticClass`.
        /// </summary>
        [FieldOffset(0x38)] public GameServiceStaticClass* pStaticClass;
    }

    /// <summary>
    /// A struct representation of the static class for storing information about a game service.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x18)]
    public struct GameServiceStaticClass
    {
        /// <summary>
        /// The name of this game service.
        /// </summary>
        [FieldOffset(0)] public Helpers.UnmanagedString Name;

        public override string ToString() => Name.ToString();
    }
}
Library "Allocators" by "Hyper, Sajid & ĐeäTh"
{
    #include "Helpers" noemit

    /// <summary>
    /// A struct representation of the `csl::fnd::IAllocator` interface.
    /// </summary>
    public struct IAllocator
    {
        /// <summary>
        /// Destroys an instance of an allocator with the `csl::fnd::IAllocator` interface.
        /// </summary>
        /// <param name="in_pThis">The instance to destroy.</param>
        VFUNCTION_PTR(IAllocator, 0, void, Dtor, IAllocator* in_pThis)
        
        /// <summary>
        /// Allocates an amount of memory to be used for a resource.
        /// </summary>
        /// <param name="in_size">The amount of memory to allocate.</param>
        /// <param name="in_alignment">The alignment of the data.</param>
        VFUNCTION_PTR(IAllocator, 1, void*, Alloc, IAllocator* in_pThis, long in_size, int in_alignment)

        /// <summary>
        /// Frees used memory at a location.
        /// </summary>
        /// <param name="in_pMemory">A pointer to the memory to free.</param>
        VFUNCTION_PTR(IAllocator, 2, void, Free, IAllocator* in_pThis, void* in_pMemory)
    }
}
Library "GameManager" by "Hyper, ĐeäTh & Sajid" 
{
    #include "Helpers" noemit
    
    #lib "GameObject"
    #lib "GameService"
    #lib "Memory"
    
    #import "Collections"

    using System.Runtime.InteropServices;
    
    /// <summary>
    /// A struct representation of `hh::game::GameManager`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x358)]
    public struct Data
    {
        /// <summary>
        /// An array of pointers to `hh::game::GameObject` instances.
        /// </summary>
        [FieldOffset(0x130)] public ObjectMoveArray<Memory.Pointer<GameObject.Data>> GameObjects;

        /// <summary>
        /// An array of pointers to `hh::game::GameService` instances.
        /// </summary>
        [FieldOffset(0x150)] public ObjectMoveArray<Memory.Pointer<GameService.Data>> GameServices;
    }

    /* v1.1.0.0:  0x1409F1F9A */
    /* v1.1.0.1:  0x1409F226A */
    /* v1.10.0.0: 0x140A1D514 */
    private static long _sigGameManagerSingleton = (long)ScanSignature
    (
        "\x4C\x89\x3D\xCC\xCC\xCC\xCC\x49\x8B\x5B\x38",
        "xxx????xxxx"
    );
    
    public Data* Get()
    {
        if (_sigGameManagerSingleton == 0)
            return null;
        
        return *(Data**)Memory.ReadEffectiveAddress(_sigGameManagerSingleton);
    }
    
    public GameService.Data* GetService(string in_name)
    {
        var pGameManager = Get();

        if (pGameManager == null)
            return null;
        
        var gameServices = pGameManager->GameServices;

        for (int i = 0; i < gameServices.Length; i++)
        {
            var pGameService = gameServices[i].pData;
            
            if (pGameService->pStaticClass->Name == in_name)
                return pGameService;
        }

        return null;
    }
    
    MAKE_STATIC_GENERIC_API(GetService)
    
    public GameObject.Data* GetGameObject(string in_name)
    {
        var pGameManager = Get();

        if (pGameManager == null)
            return null;
        
        var gameObjects = pGameManager->GameObjects;

        for (int i = 0; i < gameObjects.Length; i++)
        {
            var pGameObject = gameObjects[i].pData;

            if (pGameObject->Name == in_name)
                return pGameObject;
        }

        return null;
    }
    
    MAKE_STATIC_GENERIC_API(GetGameObject)
}
Library "States" by "Hyper"
{
    #include "Helpers" noemit

    #lib "Helpers"
    #lib "Memory"

    #import "Collections"
    
    using System.Runtime.InteropServices;

    /// <summary>
    /// A struct representation of `hh::ut::internal::StateImpl`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x30)]
    public struct StateImpl
    {
        /// <summary>
        /// The virtual function table of this state.
        /// </summary>
        [FieldOffset(0)]    public long pVftable;

        [FieldOffset(0x08)] public long pAllocator;

        /// <summary>
        /// The unique ID pertaining to this state.
        /// </summary>
        [FieldOffset(0x18)] public int StateID;

        /// <summary>
        /// The name of this state.
        /// </summary>
        [FieldOffset(0x20)] public Helpers.UnmanagedString Name;

        [FieldOffset(0x28)] public void* pContext;
    }

    /// <summary>
    /// A struct representation of `hh::ut::internal::StateDescImpl`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x18)]
    public struct StateDescImpl
    {
        /// <summary>
        /// The name of this state.
        /// </summary>
        [FieldOffset(0)] public Helpers.UnmanagedString Name;
    }

    /// <summary>
    /// A struct representation of `hh::ut::StateBase`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 0xB0)]
    public struct StateBase
    {
        public StateImpl Base;
    }

    /// <summary>
    /// A struct representation of `hh::ut::StateBase`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x20)]
    public struct StateDesc { }

    /// <summary>
    /// A struct representation of `hh::ut::internal::HsmImpl`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x70)]
    public struct HsmImpl
    {
        /// <summary>
        /// The unique ID pertaining to this state.
        /// </summary>
        [FieldOffset(0x08)] public int StateID;

        /// <summary>
        /// The index of the current state.
        /// </summary>
        [FieldOffset(0x0C)] public int CurrentStateIndex;

        /// <summary>
        /// An array of pointers to `hh::ut::internal::StateImpl` instances.
        /// </summary>
        [FieldOffset(0x20)] public ObjectMoveArray<Memory.Pointer<StateImpl>> States;

        /// <summary>
        /// A pointer to an instance of `hh::ut::internal::StateImpl`.
        /// </summary>
        [FieldOffset(0x40)] public StateImpl* pState;
    }

    /// <summary>
    /// A struct representation of `hh::ut::HsmBase`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 0x70)]
    public struct HsmBase
    {
        public HsmImpl Base;
    }
}
Library "GOComponents" by "Hyper"
{
    #lib "GameObject"
    #lib "Helpers"

    #import "States"

    #load "System.Numerics.dll"
    
    using System.Numerics;
    using System.Runtime.InteropServices;

    /// <summary>
    /// A struct representation of `hh::game::GOComponent`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x80)]
    public struct GOComponent
    {
        /// <summary>
        /// A pointer to an instance of `hh::game::GameObject` acting as the parent of this component.
        /// </summary>
        [FieldOffset(0x28)] public GameObject.Data* pGameObject;

        /// <summary>
        /// A pointer to an instance of `GOComponentStaticClass`.
        /// </summary>
        [FieldOffset(0x48)] public GOComponentStaticClass* pStaticClass;
    }

    /// <summary>
    /// A struct representation of the static class for storing information about a game object component.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x18)]
    public struct GOComponentStaticClass
    {
        /// <summary>
        /// The name of this game object component.
        /// </summary>
        [FieldOffset(0)] public Helpers.UnmanagedString Name;

        public override string ToString() => Name.ToString();
    }

    /// <summary>
    /// A struct representation of `app::player::GOCPlayerHsm`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x170)]
    public struct GOCPlayerHsm
    {
        [FieldOffset(0)]    public GOComponent Base;
        
        /// <summary>
        /// A pointer to an instance of `hh::ut::HsmBase`.
        /// </summary>
        [FieldOffset(0x88)]  public HsmBase Hsm;

        /// <summary>
        /// The current state ID.
        /// </summary>
        [FieldOffset(0x114)] public int StateID;

        /// <summary>
        /// The current state's parent ID.
        /// </summary>
        [FieldOffset(0x118)] public int ParentStateID;

        /// <summary>
        /// Gets the current state ID.
        /// </summary>
        /// <returns>The current state ID.</returns>
        public int GetStateID()
        {
            if (Hsm.Base.CurrentStateIndex != 0)
                return Hsm.Base.States[Hsm.Base.CurrentStateIndex - 1].pData->StateID;

            return -1;
        }
    }

    /// <summary>
    /// A struct representation of `app::player::GOCPlayerKinematicParams`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x5E0, Pack = 0x10)]
    public struct GOCPlayerKinematicParams
    {
        [FieldOffset(0)]     public GOComponent Base;
        
        /// <summary>
        /// The current position of the player.
        /// </summary>
        [FieldOffset(0x80)]  public Vector3 Position;

        /// <summary>
        /// The current rotation of the player.
        /// </summary>
        [FieldOffset(0x90)]  public Quaternion Rotation;

        /// <summary>
        /// The current velocity of the player.
        /// </summary>
        [FieldOffset(0xD0)]  public Vector3 Velocity;

        [FieldOffset(0x130)] public Vector3 WorldInput;
        
        /// <summary>
        /// Bit flags for kinematics.
        /// </summary>
        [FieldOffset(0x1C4)] public KinematicsFlags Flags;

        /// <summary>
        /// An enum containing known flags for player kinematics.
        /// </summary>
        [Flags]
        public enum KinematicsFlags : byte
        {
            /// <summary>
            /// The player is not on the ground.
            /// </summary>
            IsUngrounded = 2
        }
    }

    /// <summary>
    /// A struct representation of `app::player::GOCPlayerParameter`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x198)]
    public struct GOCPlayerParameter
    {
        [FieldOffset(0)]    public GOComponent Base;
        
        /// <summary>
        /// The current mode package type.
        /// </summary>
        [FieldOffset(0xB0)] public ModePackageType CurrentModePackageType;

        /// <summary>
        /// An enum containing the different mode package types from the player's reflection data.
        /// </summary>
        public enum ModePackageType : int
        {
            /// <summary>
            /// The player is in 3D.
            /// </summary>
            ForwardView,

            /// <summary>
            /// The player is in 2D.
            /// </summary>
            SideView,

            /// <summary>
            /// The player is fighting a boss.
            /// </summary>
            Boss,

            /// <summary>
            /// The player is in White Space.
            /// </summary>
            WhiteSpace
        }
    }
    
    /// <summary>
    /// A struct representation of `hh::ui::GOCSprite`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x230)]
    public struct GOCSprite
    {
        [FieldOffset(0)]     public GOComponent Base;

        /// <summary>
        /// A pointer to an instance of `hh::ui::GOCSprite::Renderable`.
        /// </summary>
        [FieldOffset(0x178)] public Renderable* pRenderable;
        
        /// <summary>
        /// Bit flags for the sprite state.
        /// </summary>
        [FieldOffset(0x180)] public byte Flags;

        /// <summary>
        /// A struct representation of `hh::ui::GOCSprite::Renderable`.
        /// </summary>
        [StructLayout(LayoutKind.Explicit, Size = 0x58)]
        public struct Renderable
        {
            /// <summary>
            /// The name of this renderable.
            /// </summary>
            [FieldOffset(0x38)] public Helpers.UnmanagedString Name;

            /// <summary>
            /// A pointer to an instance of `hh::ui::GOCSprite` acting as the parent of this object.
            /// </summary>
            [FieldOffset(0x50)] public GOCSprite* pGOCSprite;
        }
    }
}
Library "GameObject" by "Hyper, ĐeäTh & Sajid" 
{
    #include "Helpers" noemit
    
    #import "Collections"
    #import "GOComponents"

    #lib "Helpers"
    #lib "GameManager"
    #lib "Memory"

    using System.Runtime.InteropServices;

    /// <summary>
    /// A struct representation of `hh::game::GameObject`.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 0x258, Pack = 0x10)]
    public struct Data
    {
        /// <summary>
        /// The flags for this game object.
        /// </summary>
        [FieldOffset(0x30)] public byte Flags;

        /// <summary>
        /// A pointer to an instance of `app::GameManager`.
        /// </summary>
        [FieldOffset(0x48)] public GameManager.Data* pGameManager;

        /// <summary>
        /// An array of pointers to `hh::game::GOComponent` instances.
        /// </summary>
        [FieldOffset(0x58)] public ObjectMoveArray<Memory.Pointer<GOComponent>> Components;

        /// <summary>
        /// The name of this game object.
        /// </summary>
        [FieldOffset(0xB8)] public Helpers.UnmanagedString Name;

        public override string ToString() => Name.ToString();

        /// <summary>
        /// Destroys this game object.
        /// </summary>
        public void Kill()
        {
            Flags |= 1;
        }

        public GOComponent* GetGOC(string in_name)
        {
            for (int i = 0; i < Components.Length; i++)
            {
                var pComponent = Components[i].pData;
                
                if (pComponent->pStaticClass->Name == in_name)
                    return pComponent;
            }

            return null;
        }

        MAKE_GENERIC_API(GetGOC)
    }
}
Patch "Fix Grind Step Magnetism" in "Fixes" by "Hyper" does "Fixes the player stopping and magnetising to grind rails whilst trying to switch between them."
//
    #lib "Memory"
//
{
    // v1.1.0.0:  0x1406CCE66
    // v1.1.0.1:  0x1406CD116
    // v1.10.0.0: 0x1406F0478
    var sig = ScanSignature
    (
        "\x48\x8B\xCB\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x77\x48\x8B\xCF",
        "xxxx????xxxxxxx"
    );

    if (sig == 0)
        return;

    var func = Memory.ReadCall(sig + 3);
    var jump = Memory.ReadJump(sig + 10);

    WriteAsmHook
    (
        $@"
            mov  rcx, rbx                    ; RCX = ShadowContext
            mov  rax, {func}
            call rax
            test al, al
            jnz  exit
            mov  rcx, qword ptr [rbx + 0x28] ; RCX = BlackboardStatus
            mov  rcx, qword ptr [rcx + 0x38] ; RCX = BlackboardStatus->StateFlags
            test rcx, 0x120                  ; Check grind step flags
            jnz  exit
            mov  rax, {jump}
            jmp  rax
        exit:
            mov  rcx, rdi
        ",

        sig,

        HookBehavior.Replace
    );
}
Patch "Bouncy Jump Ball" in "Animation" by "Hyper" does "Uses bouncy jump ball animations when jumping, similar to Sonic Forces."
//
    #include "Helpers" noemit

    #lib "Memory"
//
{
    // v1.1.0.0: 0x1406E8C90
    // v1.1.0.1: 0x1406E8F40
    long sigPlayAnimationEffectAddr = Memory.ReadCall
    (
        /* v1.1.0.0: 0x14C5E1FAA */
        /* v1.1.0.1: 0x14B402E1A */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x89\xF2\x48\x89\xF9\xE8\xCC\xCC\xCC\xCC\x80\x8F\xF4\x00\x00\x00\x01",
            "x????xxxxxxx????xxxxxxx"
        )
    );

    WriteAsmHook
    (
        $@"
            mov  r8b, 1
            mov  rdx, {TO_STRING_PTR("SPINJUMP")}
            mov  rcx, rsi
            mov  rax, {sigPlayAnimationEffectAddr}
            call rax
        ",

        /* v1.1.0.0: 0x14C5E1F9D */
        /* v1.1.0.1: 0x14B402E0D */
        ScanSignature
        (
            "\x41\xB0\x01\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x89\xF1",
            "xxxxxx????xxx"
        ),

        HookBehavior.Replace
    );
}
Patch "Disable Head Targeting" in "Animation" by "Hyper" does "Disables Shadow turning his head to look at objects (e.g. NPCs)."
//
    #lib "Memory"
//
{
    Memory.WriteForceJump
    (
        /* v1.1.0.0: 0x1406CFBDB */
        /* v1.1.0.1: 0x1406CFE8B */
        ScanSignature
        (
            "\x0F\x85\x8D\x00\x00\x00\xBA\x01\x00\x00\x00\x48\x8B\xCE",
            "xxxxxxxxxxxxxx"
        )
    );
}
Patch "Disable Flying Boost Fall" in "Animation" by "Hyper" does "Disables the animation where Shadow continues flying whilst boosting when falling off a platform, forcing him into the normal falling animation."
//
    #include "Helpers" noemit
//
{
    WriteAsmHook
    (
        $@"
            mov r14, {TO_STRING_PTR("GRIND_FALL")}
            cmp r12d, 0x2C
            jz  exit
            mov r14, {TO_STRING_PTR("FALL")}
        exit:
        ",

        /* v1.1.0.0:  0x140694D77 */
        /* v1.1.0.1:  0x140695027 */
        /* v1.10.0.0: 0x1406B7841 */
        ScanSignature
        (
            "\x4C\x8D\x35\xCC\xCC\xCC\xCC\x41\x83\xFC\x2C",
            "xxx????xxxx"
        ),

        HookBehavior.Replace
    );
}
Patch "Disable FPS Limit in Cutscenes (experimental)" in "Graphics/Display" by "M&M & Hyper" does 
/*
Disables the frame rate limiter for (most) cutscenes, allowing them to run above 30 FPS.

Known issues;
- Certain cutscenes will still operate at 30 FPS due to how this game syncs cutscene audio.
*/
//
    #lib "Memory"
//
{
    // v1.1.0.0: 0x14782FA63
    // v1.1.0.1: 0x147231BC9
    long jmpAddr = ScanSignature
    (
        "\x74\x35\x48\x8B\x05\xCC\xCC\xCC\xCC\xF3\x0F\x10\x0D\xCC\xCC\xCC\xCC\xC6\x40\x10\x01\x48\x8B\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\xF3\x0F\x10\x05\xCC\xCC\xCC\xCC\x41\xB0\x01\x31\xD2",
        "xxxxx????xxxx????xxxxxxx????x????xxxx????xxxxx"
    );

    if (jmpAddr == 0)
        return;
    
    Memory.WriteForceJump(jmpAddr);
}
Code "Adjust Aspect Ratio to Resolution (experimental)" in "Graphics/Display" by "M&M & Hyper" does 
/*
Dynamically adjusts the aspect ratio to match the game resolution (recommended for non-16:9 resolutions).

Notes;
- This code will still function at 16:9 resolutions, but will only fix minor aspect ratio issues (such as improper cutscene aspect ratio).

Known issues;
- The UI still renders at 16:9 and details that are supposed to be off screen will be visible at wider aspect ratios.
- Pre-rendered cutscenes will stretch to your aspect ratio.
- The expected aspect ratio will only apply to a newly set resolution when you change the screen mode to another and back.
- Vignette (the circular shadowing effect on the screen) is pretty egregious at aspect ratios wider than 21:9, it is highly recommended to use the Disable Vignette code to remove it.
*/
//
    #lib "Win32"

    using System.Diagnostics;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    struct RECT
    {
        public int Left;
        public int Top;
        public int Right;
        public int Bottom;
    }

    [DllImport("user32.dll")]
    static extern bool GetClientRect(IntPtr hWnd, ref RECT lpRect);

    static bool _isInitialised = false;

    static float _aspectRatio = 1920.0f / 1080.0f;
    static float _eventFieldOfView = 0.0f;

    static long _mainAspectRatioAddr = 0;
    static long _dvSceneAspectRatioAddr = 0;
//
{
    if (!_isInitialised)
    {
        // v1.1.0.0:  0x14012EE57
        // v1.1.0.1:  0x14012F107
        // v1.10.0.0: 0x140134327
        long mainAspectRatioInstrAddr = ScanSignature
        (
            "\xF3\x0F\x59\x05\xCC\xCC\xCC\xCC\x89\x4C\x24\x3C",
            "xxxx????xxxx"
        );

        // v1.1.0.0/v1.1.0.1: 0x1411669B4
        // v1.10.0.0: 0x141196424
        _mainAspectRatioAddr = mainAspectRatioInstrAddr + Read<uint>(mainAspectRatioInstrAddr + 4) + 8;

        // v1.1.0.0:  0x140A6867C
        // v1.1.0.1:  0x140A6894C
        // v1.10.0.0: 0x140A9351C
        _dvSceneAspectRatioAddr = ScanSignature
        (
            "\xC7\x81\x04\x02\x00\x00\x39\x8E\xE3\x3F",
            "xxxxxxxxxx"
        );

        fixed (float* p_aspectRatio = &_aspectRatio)
        fixed (float* p_eventFieldOfView = &_eventFieldOfView)
        {
            WriteAsmHook
            (
                $@"
                    movss  dword ptr [rsi + 0x54], xmm0

                    ; check if current event aspect ratio has been modified
                    mov    rcx, {(long)p_aspectRatio}
                    movss  xmm0, dword ptr [rcx]
                    movss  xmm1, dword ptr [rsi + 0x58]
                    comiss xmm0, xmm1
                    je     exit

                    ; multiply original aspect ratio by new aspect ratio
                    movss  xmm0, dword ptr [rsi + 0x58]
                    mov    rcx, {(long)p_aspectRatio}
                    movss  xmm1, dword ptr [rcx]
                    divps  xmm0, xmm1
                    movss  xmm1, xmm0

                    ; compute new field of view from aspect ratio difference
                    movss  xmm0, dword ptr [rsi + 0x54]
                    mulps  xmm0, xmm1
                    movss  dword ptr [rsi + 0x54], xmm0
                    mov    rcx, {(long)p_eventFieldOfView}
                    movss  dword ptr [rcx], xmm0

                exit:
                    ; set new aspect ratio
                    mov    rcx, {(long)p_aspectRatio}
                    mov    ecx, dword ptr [rcx]
                    mov    dword ptr [rsi + 0x58], ecx

                    ; restore original code
                    mov    ecx, dword ptr [rdi + 0x14]
                    bswap  ecx
                    mov    dword ptr [rsi + 0x70], ecx
                    test   ecx, ecx
                ",

                /* v1.10.0.0: 0x140F388D5 */
                ScanSignature
                (
                    "\xF3\x0F\x11\x46\x54\x8B\x4F\x14",
                    "xxxxxxxx"
                ),

                HookBehavior.Replace
            );
        }

        _isInitialised = true;
    }

    if (_mainAspectRatioAddr == 0)
        return;

    var clientRect = new RECT();

    if (!GetClientRect(Win32.GetGameWindowHandle(), ref clientRect))
        return;

    float width  = (float)(clientRect.Right - clientRect.Left);
    float height = (float)(clientRect.Bottom - clientRect.Top);

    _aspectRatio = width / height;

    WriteProtected<float>(_mainAspectRatioAddr, _aspectRatio);

    if (_dvSceneAspectRatioAddr != 0)
        WriteProtected<float>(_dvSceneAspectRatioAddr + 6, _aspectRatio);
}
Patch "Disable FPS Limit (experimental)" in "Graphics/Display" by "NM, M&M & Hyper" does "Disables the frame rate limiter, allowing the game to run above its targeted 30/60/120 FPS limit."
//
    #lib "Memory"
//
{
    WriteProtected<byte>
    (
        /* v1.1.0.0: 0x140A23CE8 */
        /* v1.1.0.1: 0x140A23FB8 */
        ScanSignature
        (
            "\x0F\x83\xA1\x00\x00\x00\xF2\x0F\x10\xA3\x50\x01\x00\x00",
            "xxxxxxxxxxxxxx"
        ),

        0xE9, 0xB0, 0x00, 0x00, 0x00
    );

    WriteNop
    (
        /* v1.1.0.0:  0x140A23DEB */
        /* v1.1.0.1:  0x140A240BB */
        /* v1.10.0.0: 0x140A4F0DB */
        ScanSignature
        (
            "\x72\xC3\x44\x0F\x28\x4C\x24\x30",
            "xxxxxxxx"
        ),

        2
    );

    /* The change in speed is seemingly caused by the cap not being in sync with the current FPS. To fix this, we must first uncap the value of a current FPS address.
       The cap is controlled by the opcode "cmova rax, rcx" where RAX is the calculated current FPS and RCX is the user's set FPS cap. To remove this, we will be scanning for the opcode before it. */
    WriteAsmHook
    (
        /* To get rid of the opcode which enforces the cap, we simply do not include it. We can also remove "comiss xmm1, dword ptr [rcx]" which invokes the comparison.
           With the current FPS address' value uncapped (EAX), we can now write it to the FPS cap address, which is stored in RDI. This will sync the FPS cap with the actual FPS, fixing the speedup issue. */
        @"
            mov eax, dword ptr [rax]
            mov dword ptr [rbx + 0x144], eax
            mov dword ptr [rcx], eax
        ",
        
        /* v1.1.0.0: 0x140A23EFC */
        /* v1.1.0.1: 0x140A241CC */
        ScanSignature
        (
            "\x0F\x2F\x09\x48\x0F\x47\xC1\x8B\x00",
            "xxxxxxxxx"
        ),
        
        HookBehavior.Replace
    );
    
    // v1.1.0.0: 0x14782FA63
    // v1.1.0.1: 0x147231BC9
    long jmpAddr = ScanSignature
    (
        "\x74\x35\x48\x8B\x05\xCC\xCC\xCC\xCC\xF3\x0F\x10\x0D\xCC\xCC\xCC\xCC\xC6\x40\x10\x01\x48\x8B\x0D\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\xF3\x0F\x10\x05\xCC\xCC\xCC\xCC\x41\xB0\x01\x31\xD2",
        "xxxxx????xxxx????xxxxxxx????x????xxxx????xxxxx"
    );

    if (jmpAddr == 0)
        return;
    
    // This removes the framerate limiting code for cutscenes.
    Memory.WriteForceJump(jmpAddr);
}
Patch "Disable Vignette" in "Graphics/Post-processing" by "Hyper"
{
    WriteAsmHook
    (
        "mov byte ptr [r11], 0",

        /* v1.1.0.0: 0x149623C99 */
        /* v1.1.0.1: 0x148A79989 */
        ScanSignature
        (
            "\x41\x0F\x10\x33\x0F\x29\xBC\x24\xE0\x00\x00\x00\x41\x0F\x10\x7B\x10\x44\x0F\x29\x84\x24\xD0\x00\x00\x00\x45\x0F\x10\x43\x20\x44\x0F\x29\x8C\x24\xC0\x00\x00\x00\x45\x0F\x10\x4B\x30\x44\x0F\x29\x94\x24\xB0\x00\x00\x00\x45\x0F\x10\x53\x40\x44\x0F\x29\x9C\x24\xA0\x00\x00\x00",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.After
    );
}
Patch "Disable Motion Blur" in "Graphics/Post-processing" by "Hyper"
{
    // Disable player motion blur.
    WriteProtected<byte>
    (
        /* v1.1.0.0:  0x1406C176F */
        /* v1.1.0.1:  0x1406C1A1F */
        /* v1.10.0.0: 0x1406E4D92 */
        ScanSignature
        (
            "\x41\x0F\xB6\x4F\x70",
            "xxxxx"
        ),
        
        Assemble("mov ecx, 0")
    );

    // Disable scene motion blur.
    WriteAsmHook
    (
        "mov byte ptr [r8], 0",

        /* v1.1.0.0:  0x14968103E */
        /* v1.1.0.1:  0x148AF391E */
        /* v1.10.0.0: 0x1486BDD65 */
        ScanSignature
        (
            "\x41\x0F\x28\x30\x0F\x29\xBC\x24\x80\x00\x00\x00",
            "xxxxxxxxxxxx"
        ),

        HookBehavior.After
    );
}
Patch "Disable FidelityFX Super Resolution" in "Graphics/Post-processing" by "Hyper" does
/*
Disables the upsampling post-processing applied to the game.

This will reduce sharpening artefacts like subtle haloing around geometry.
*/
{
    WriteAsmHook
    (
        $@"
            mov byte ptr [rcx + 0x01], 0
            mov dword ptr [rcx + 0x04], 0
            ret
        ",

        /* v1.1.0.0: 0x148FE99EC */
        /* v1.1.0.1: 0x1485E622C */
        ScanSignature
        (
            "\x88\x41\x01\xF3\x41\x0F\x10\x48\x04",
            "xxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}
Patch "Disable Speed Lines" in "Graphics/Post-processing" by "stis" does "Disables the speed lines around the edges of the screen whilst boosting."
{
    WriteProtected<byte>(
        /* v1.1.0.1: 0x14120FF38 */
        ScanSignature
        (
            "\x65\x66\x5F\x70\x6C\x5F\x6C\x69\x6E\x65\x5F\x73\x70\x65\x65\x64\x30\x31",
            "xxxxxxxxxxxxxxxxxx"
        ),
        0x30
    );
}

Patch "Force 4K Video Playback" in "Graphics/Quality" by "Hyper" does "Forces the game to use the pre-rendered cutscenes encoded at 4K, regardless of game resolution."
{
    WriteAsmHook
    (
        $@"
            mov al, 1
            add rsp, 0x38
            ret
        ",

        /* v1.1.0.0: 0x14E59CF53 */
        /* v1.1.0.1: 0x14CC94C8E */
        ScanSignature
        (
            "\x81\x7C\x24\x40\x80\x07\x00\x00\x76\x10",
            "xxxxxxxxxx"
        ),

        HookBehavior.Replace
    );
}
Patch "Force Maximum Geometry Detail" in "Graphics/Quality" by "Hyper" does "Forces terrain and object geometry to always render at the highest detail."
//
    using System.Runtime.InteropServices;

    /* This array is actually 32 in length, but the game
       accesses an array with tons of padding at the start. */
    static float[] _layerRange = new float[36];
//
{
    var p_layerRange = Marshal.AllocHGlobal(_layerRange.Length * sizeof(float));

    for (int i = 0; i < _layerRange.Length; i++)
        _layerRange[i] = 10000.0f;

    Marshal.Copy(_layerRange, 0, p_layerRange, _layerRange.Length);

    WriteAsmHook
    (
        $"mov rax, {(long)p_layerRange}",

        /* v1.1.0.0: 0x140E3DC42 */
        /* v1.1.0.1: 0x140E3DF12 */
        ScanSignature
        (
            "\x0F\x10\x00\x48\x8D\x55\xF4",
            "xxxxxxx"
        ),

        HookBehavior.After
    );
}
Patch "Force Higher Detail Reflections" in "Graphics/Quality" by "Hyper" does "Forces real-time local reflections to render at a higher resolution and reduces artefacting around the player and other nearby objects."
{
    WriteAsmHook
    (
        $@"
            mov byte ptr [r8 + 0x01], 1           ; enable traceSky to fix reflections for near objects
            mov byte ptr [r8 + 0x04], 0           ; disable useQuat for full resolution reflections
            mov byte ptr [r8 + 0x05], 1           ; enable useNormal to apply normal maps to reflections
            mov dword ptr [r8 + 0x08], 0x44000000 ; set rayMarchingCount to 512.0f to improve reflection quality
            mov dword ptr [r8 + 0x18], 0x3FC00000 ; set overrideRatio to 1.5f to reduce artefacting
            mov dword ptr [r8 + 0x24], 0x3E800000 ; set uvOffsetScale to 0.25f to improve reflection quality whilst retaining normal map detail
        ",

        /* v1.1.0.0: 0x1490D78F5 */
        /* v1.1.0.1: 0x148625465 */
        ScanSignature
        (
            "\xF3\x41\x0F\x10\x48\x08\xF3\x0F\x5C\x4A\x08\xF3\x0F\x59\xCB\xF3\x0F\x58\x4A\x08\xF3\x41\x0F\x11\x4A\x08",
            "xxxxxxxxxxxxxxxxxxxxxxxxxx"
        ),

        HookBehavior.After
    );
}
Patch "2x Object Draw Distance in White Space" in "Graphics/Draw Distance" by "wAABBsif" does "Extends the draw distance at which objects will display in White Space."
//
    static float _multiplier = 2.0f;
//
{
    // v1.1.0.1: 0x14018D47A
    var sig = ScanSignature
    (
        "\x0F\x29\x74\x24\x40\xF3\x0F\x10\x30",
        "xxxxxxxxx"
    );

    if (sig == 0)
        return;

    fixed (float* p_multiplier = &_multiplier)
    {
        WriteAsmHook
        (
            $@"
                movaps xmmword ptr [rsp + 0x40], xmm6
                movss  xmm6, dword ptr [rax]
                mov    rdx, {(long)p_multiplier}
                mulss  xmm6, dword ptr [rdx]        ; Multiply rangeIn value.
                movss  dword ptr [rax + 0x04], xmm6 ; Move rangeIn value into rangeOut.
                mov    edx, 0x447A0000
                movd   xmm0, edx
            ",

            sig,

            HookBehavior.Replace
        );
    }
}
Patch "1.25x Object Draw Distance in White Space" in "Graphics/Draw Distance" by "wAABBsif" does "Extends the draw distance at which objects will display in White Space."
//
    static float _multiplier = 1.25f;
//
{
    // v1.1.0.1: 0x14018D47A
    var sig = ScanSignature
    (
        "\x0F\x29\x74\x24\x40\xF3\x0F\x10\x30",
        "xxxxxxxxx"
    );

    if (sig == 0)
        return;

    fixed (float* p_multiplier = &_multiplier)
    {
        WriteAsmHook
        (
            $@"
                movaps xmmword ptr [rsp + 0x40], xmm6
                movss  xmm6, dword ptr [rax]
                mov    rdx, {(long)p_multiplier}
                mulss  xmm6, dword ptr [rdx]        ; Multiply rangeIn value.
                movss  dword ptr [rax + 0x04], xmm6 ; Move rangeIn value into rangeOut.
                mov    edx, 0x447A0000
                movd   xmm0, edx
            ",

            sig,

            HookBehavior.Replace
        );
    }
}
Patch "1.5x Object Draw Distance in White Space" in "Graphics/Draw Distance" by "wAABBsif" does "Extends the draw distance at which objects will display in White Space."
//
    static float _multiplier = 1.5f;
//
{
    // v1.1.0.1: 0x14018D47A
    var sig = ScanSignature
    (
        "\x0F\x29\x74\x24\x40\xF3\x0F\x10\x30",
        "xxxxxxxxx"
    );

    if (sig == 0)
        return;

    fixed (float* p_multiplier = &_multiplier)
    {
        WriteAsmHook
        (
            $@"
                movaps xmmword ptr [rsp + 0x40], xmm6
                movss  xmm6, dword ptr [rax]
                mov    rdx, {(long)p_multiplier}
                mulss  xmm6, dword ptr [rdx]        ; Multiply rangeIn value.
                movss  dword ptr [rax + 0x04], xmm6 ; Move rangeIn value into rangeOut.
                mov    edx, 0x447A0000
                movd   xmm0, edx
            ",

            sig,

            HookBehavior.Replace
        );
    }
}
